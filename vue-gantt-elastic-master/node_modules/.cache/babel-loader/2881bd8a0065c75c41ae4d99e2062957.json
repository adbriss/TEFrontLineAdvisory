{"remainingRequest":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/babel-loader/lib/index.js!/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/gantt-elastic/src/GanttElastic.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/gantt-elastic/src/GanttElastic.vue","mtime":1664650536314},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/cache-loader/dist/cjs.js","mtime":1664650533042},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/babel-loader/lib/index.js","mtime":1664650533420},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/cache-loader/dist/cjs.js","mtime":1664650533042},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/vue-loader/lib/index.js","mtime":1664650526464}],"contextDependencies":[],"result":["import \"core-js/modules/es6.number.constructor\";\nimport \"core-js/modules/es6.number.max-safe-integer\";\nimport \"core-js/modules/es6.object.keys\";\nimport _objectSpread from \"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _slicedToArray from \"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _typeof from \"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/@babel/runtime-corejs2/helpers/esm/typeof\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.function.name\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport VueInstance from 'vue';\nimport dayjs from 'dayjs';\nimport MainView from \"./components/MainView.vue\";\nimport getStyle from \"./style.js\";\nimport ResizeObserver from 'resize-observer-polyfill';\nvar ctx = document.createElement('canvas').getContext('2d');\nvar VueInst = VueInstance;\n\nfunction initVue() {\n  if (typeof Vue !== 'undefined' && typeof VueInst === 'undefined') {\n    VueInst = Vue;\n  }\n}\n\ninitVue();\nvar hourWidthCache = null;\n/**\n * Helper function to fill out empty options in user settings\n *\n * @param {object} userOptions - initial user options that will merge with those below\n * @returns {object} merged options\n */\n\nfunction getOptions(userOptions) {\n  var localeName = 'en';\n\n  if (typeof userOptions.locale !== 'undefined' && typeof userOptions.locale.name !== 'undefined') {\n    localeName = userOptions.locale.name;\n  }\n\n  return {\n    slots: {\n      header: {}\n    },\n    taskMapping: {\n      //*\n      id: 'id',\n      start: 'start',\n      label: 'label',\n      duration: 'duration',\n      progress: 'progress',\n      type: 'type',\n      style: 'style',\n      collapsed: 'collapsed'\n    },\n    width: 0,\n    height: 0,\n    clientWidth: 0,\n    outerHeight: 0,\n    rowsHeight: 0,\n    allVisibleTasksHeight: 0,\n    scroll: {\n      scrolling: false,\n      dragXMoveMultiplier: 3,\n      //*\n      dragYMoveMultiplier: 2,\n      //*\n      top: 0,\n      taskList: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      },\n      chart: {\n        left: 0,\n        right: 0,\n        percent: 0,\n        timePercent: 0,\n        top: 0,\n        bottom: 0,\n        time: 0,\n        timeCenter: 0,\n        dateTime: {\n          left: '',\n          right: ''\n        }\n      }\n    },\n    scope: {\n      //*\n      before: 1,\n      after: 1\n    },\n    times: {\n      timeScale: 60 * 1000,\n      timeZoom: 17,\n      //*\n      timePerPixel: 0,\n      firstTime: null,\n      lastTime: null,\n      firstTaskTime: 0,\n      lastTaskTime: 0,\n      totalViewDurationMs: 0,\n      totalViewDurationPx: 0,\n      stepDuration: 'day',\n      steps: []\n    },\n    row: {\n      height: 24 //*\n\n    },\n    maxRows: 20,\n    //*\n    maxHeight: 0,\n    //*\n    chart: {\n      grid: {\n        horizontal: {\n          gap: 6 //*\n\n        }\n      },\n      progress: {\n        width: 20,\n        //*\n        height: 6,\n        //*\n        pattern: true,\n        bar: false\n      },\n      text: {\n        offset: 4,\n        //*\n        xPadding: 10,\n        //*\n        display: true //*\n\n      },\n      expander: {\n        type: 'chart',\n        display: false,\n        //*\n        displayIfTaskListHidden: true,\n        //*\n        offset: 4,\n        //*\n        size: 18\n      }\n    },\n    taskList: {\n      display: true,\n      //*\n      resizeAfterThreshold: true,\n      //*\n      widthThreshold: 75,\n      //*\n      columns: [//*\n      {\n        id: 0,\n        label: 'ID',\n        value: 'id',\n        width: 40\n      }],\n      percent: 100,\n      //*\n      width: 0,\n      finalWidth: 0,\n      widthFromPercentage: 0,\n      minWidth: 18,\n      expander: {\n        type: 'task-list',\n        size: 16,\n        columnWidth: 24,\n        padding: 16,\n        margin: 10,\n        straight: false\n      }\n    },\n    calendar: {\n      workingDays: [1, 2, 3, 4, 5],\n      //*\n      gap: 6,\n      //*\n      height: 0,\n      strokeWidth: 1,\n      hour: {\n        height: 20,\n        //*\n        display: true,\n        //*\n        widths: [],\n        maxWidths: {\n          short: 0,\n          medium: 0,\n          long: 0\n        },\n        formatted: {\n          long: [],\n          medium: [],\n          short: []\n        },\n        format: {\n          //*\n          long: function long(date) {\n            return date.format('HH:mm');\n          },\n          medium: function medium(date) {\n            return date.format('HH:mm');\n          },\n          short: function short(date) {\n            return date.format('HH');\n          }\n        }\n      },\n      day: {\n        height: 20,\n        //*\n        display: true,\n        //*\n        widths: [],\n        maxWidths: {\n          short: 0,\n          medium: 0,\n          long: 0\n        },\n        format: {\n          long: function long(date) {\n            return date.format('DD dddd');\n          },\n          medium: function medium(date) {\n            return date.format('DD ddd');\n          },\n          short: function short(date) {\n            return date.format('DD');\n          }\n        }\n      },\n      month: {\n        height: 20,\n        //*\n        display: true,\n        //*\n        widths: [],\n        maxWidths: {\n          short: 0,\n          medium: 0,\n          long: 0\n        },\n        format: {\n          //*\n          short: function short(date) {\n            return date.format('MM');\n          },\n          medium: function medium(date) {\n            return date.format(\"MMM 'YY\");\n          },\n          long: function long(date) {\n            return date.format('MMMM YYYY');\n          }\n        }\n      }\n    },\n    locale: {\n      //*\n      name: 'en',\n      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n      weekStart: 1,\n      relativeTime: {\n        future: 'in %s',\n        past: '%s ago',\n        s: 'a few seconds',\n        m: 'a minute',\n        mm: '%d minutes',\n        h: 'an hour',\n        hh: '%d hours',\n        d: 'a day',\n        dd: '%d days',\n        M: 'a month',\n        MM: '%d months',\n        y: 'a year',\n        yy: '%d years'\n      },\n      formats: {\n        LT: 'HH:mm',\n        LTS: 'HH:mm:ss',\n        L: 'DD/MM/YYYY',\n        LL: 'D MMMM YYYY',\n        LLL: 'D MMMM YYYY HH:mm',\n        LLLL: 'dddd, D MMMM YYYY HH:mm'\n      },\n      ordinal: function ordinal(n) {\n        var s = ['th', 'st', 'nd', 'rd'];\n        var v = n % 100;\n        return \"[\".concat(n).concat(s[(v - 20) % 10] || s[v] || s[0], \"]\");\n      }\n    }\n  };\n}\n/**\n * Prepare style\n *\n * @returns {object}\n */\n\n\nfunction prepareStyle(userStyle) {\n  var fontSize = '12px';\n  var fontFamily = window.getComputedStyle(document.body).getPropertyValue('font-family').toString();\n\n  if (typeof userStyle !== 'undefined') {\n    if (typeof userStyle.fontSize !== 'undefined') {\n      fontSize = userOptions.fontSize;\n    }\n\n    if (typeof userStyle.fontFamily !== 'undefined') {\n      fontFamily = userStyle.fontFamily;\n    }\n  }\n\n  return getStyle(fontSize, fontFamily);\n}\n/**\n * Helper function to determine if specified variable is an object\n *\n * @param {any} item\n *\n * @returns {boolean}\n */\n\n\nfunction isObject(item) {\n  return item && _typeof(item) === 'object' && !Array.isArray(item) && !(item instanceof HTMLElement) && !(item instanceof CanvasRenderingContext2D) && typeof item !== 'function';\n}\n/**\n * Helper function which will merge objects recursively - creating brand new one - like clone\n *\n * @param {object} target\n * @params {object} sources\n *\n * @returns {object}\n */\n\n\nexport function mergeDeep(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (!sources.length) {\n    return target;\n  }\n\n  var source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (var key in source) {\n      if (isObject(source[key])) {\n        if (typeof target[key] === 'undefined') {\n          target[key] = {};\n        }\n\n        target[key] = mergeDeep(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        target[key] = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = source[key][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var item = _step.value;\n\n            if (isObject(item)) {\n              target[key].push(mergeDeep({}, item));\n              continue;\n            }\n\n            target[key].push(item);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return mergeDeep.apply(void 0, [target].concat(sources));\n}\n/**\n * Detect if object or array is observable\n *\n * @param {object|array} obj\n *\n * @returns {boolean}\n */\n\nfunction isObservable(obj) {\n  return _typeof(obj) === 'object' && obj.hasOwnProperty('__ob__');\n}\n/**\n * Same as above but with reactivity in mind\n *\n * @param {object} target\n * @params {object} sources\n *\n * @returns {object}\n */\n\n\nexport function mergeDeepReactive(component, target) {\n  for (var _len2 = arguments.length, sources = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    sources[_key2 - 2] = arguments[_key2];\n  }\n\n  if (!sources.length) {\n    return target;\n  }\n\n  var source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (var key in source) {\n      if (isObject(source[key])) {\n        if (typeof target[key] === 'undefined') {\n          component.$set(target, key, {});\n        }\n\n        mergeDeepReactive(component, target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        component.$set(target, key, source[key]);\n      } else if (typeof source[key] === 'function') {\n        if (source[key].toString().indexOf('[native code]') === -1) {\n          target[key] = source[key];\n        }\n      } else {\n        component.$set(target, key, source[key]);\n      }\n    }\n  }\n\n  return mergeDeepReactive.apply(void 0, [component, target].concat(sources));\n}\n/**\n * Check if objects or arrays are equal by comparing nested values\n *\n * @param {object|array} left\n * @param {object|array} right\n *\n * @returns {boolean}\n */\n\nexport function notEqualDeep(left, right) {\n  var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\n  if (_typeof(right) !== _typeof(left)) {\n    return {\n      left: left,\n      right: right,\n      what: path + '.typeof'\n    };\n  } else if (Array.isArray(left) && !Array.isArray(right)) {\n    return {\n      left: left,\n      right: right,\n      what: path + '.isArray'\n    };\n  } else if (Array.isArray(right) && !Array.isArray(left)) {\n    return {\n      left: left,\n      right: right,\n      what: path + '.isArray'\n    };\n  } else if (Array.isArray(left) && Array.isArray(right)) {\n    if (left.length !== right.length) {\n      return {\n        left: left,\n        right: right,\n        what: path + '.length'\n      };\n    }\n\n    var what;\n\n    for (var index = 0, len = left.length; index < len; index++) {\n      if (what = notEqualDeep(left[index], right[index], cache, path + '.' + index)) {\n        return what;\n      }\n    }\n  } else if (isObject(left) && !isObject(right)) {\n    return {\n      left: left,\n      right: right,\n      what: path + '.isObject'\n    };\n  } else if (isObject(right) && !isObject(left)) {\n    return {\n      left: left,\n      right: right,\n      what: path + '.isObject'\n    };\n  } else if (isObject(left) && isObject(right)) {\n    for (var key in left) {\n      if (!left.hasOwnProperty(key) || !left.propertyIsEnumerable(key)) {\n        continue;\n      }\n\n      if (!right.hasOwnProperty(key)) {\n        return {\n          left: left,\n          right: right,\n          what: path + '.' + key\n        };\n      }\n\n      var _what = void 0;\n\n      if (_what = notEqualDeep(left[key], right[key], cache, path + '.' + key)) {\n        return _what;\n      }\n    }\n  } else if (left !== right) {\n    return {\n      left: left,\n      right: right,\n      what: path + '. !=='\n    };\n  }\n\n  return false;\n}\n/**\n * GanttElastic\n * Main vue component\n */\n\nvar GanttElastic = {\n  name: 'GanttElastic',\n  components: {\n    MainView: MainView\n  },\n  props: ['tasks', 'options', 'dynamicStyle'],\n  provide: function provide() {\n    var provider = {};\n    var self = this;\n    Object.defineProperty(provider, 'root', {\n      enumerable: true,\n      get: function get() {\n        return self;\n      }\n    });\n    return provider;\n  },\n  data: function data() {\n    return {\n      state: {\n        tasks: [],\n        options: {\n          scrollBarHeight: 0,\n          allVisibleTasksHeight: 0,\n          outerHeight: 0,\n          scroll: {\n            left: 0,\n            top: 0\n          }\n        },\n        dynamicStyle: {},\n        refs: {},\n        tasksById: {},\n        taskTree: {},\n        ctx: ctx,\n        emitTasksChanges: true,\n        // some operations may pause emitting changes to parent component\n        emitOptionsChanges: true,\n        // some operations may pause emitting changes to parent component\n        resizeObserver: null,\n        unwatchTasks: null,\n        unwatchOptions: null,\n        unwatchStyle: null,\n        unwatchOutputTasks: null,\n        unwatchOutputOptions: null,\n        unwatchOutputStyle: null\n      }\n    };\n  },\n  methods: {\n    mergeDeep: mergeDeep,\n    mergeDeepReactive: mergeDeepReactive,\n\n    /**\n     * Calculate height of scrollbar in current browser\n     *\n     * @returns {number}\n     */\n    getScrollBarHeight: function getScrollBarHeight() {\n      var outer = document.createElement('div');\n      outer.style.visibility = 'hidden';\n      outer.style.height = '100px';\n      outer.style.msOverflowStyle = 'scrollbar';\n      document.body.appendChild(outer);\n      var noScroll = outer.offsetHeight;\n      outer.style.overflow = 'scroll';\n      var inner = document.createElement('div');\n      inner.style.height = '100%';\n      outer.appendChild(inner);\n      var withScroll = inner.offsetHeight;\n      outer.parentNode.removeChild(outer);\n      var height = noScroll - withScroll;\n      this.style['chart-scroll-container--vertical']['margin-left'] = \"-\".concat(height, \"px\");\n      return this.state.options.scrollBarHeight = height;\n    },\n\n    /**\n     * Fill out empty task properties and make it reactive\n     *\n     * @param {array} tasks\n     */\n    fillTasks: function fillTasks(tasks) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = tasks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var task = _step2.value;\n\n          if (typeof task.x === 'undefined') {\n            task.x = 0;\n          }\n\n          if (typeof task.y === 'undefined') {\n            task.y = 0;\n          }\n\n          if (typeof task.width === 'undefined') {\n            task.width = 0;\n          }\n\n          if (typeof task.height === 'undefined') {\n            task.height = 0;\n          }\n\n          if (typeof task.mouseOver === 'undefined') {\n            task.mouseOver = false;\n          }\n\n          if (typeof task.collapsed === 'undefined') {\n            task.collapsed = false;\n          }\n\n          if (typeof task.dependentOn === 'undefined') {\n            task.dependentOn = [];\n          }\n\n          if (typeof task.parentId === 'undefined') {\n            task.parentId = null;\n          }\n\n          if (typeof task.style === 'undefined') {\n            task.style = {};\n          }\n\n          if (typeof task.children === 'undefined') {\n            task.children = [];\n          }\n\n          if (typeof task.allChildren === 'undefined') {\n            task.allChildren = [];\n          }\n\n          if (typeof task.parents === 'undefined') {\n            task.parents = [];\n          }\n\n          if (typeof task.parent === 'undefined') {\n            task.parent = null;\n          }\n\n          if (typeof task.startTime === 'undefined') {\n            task.startTime = dayjs(task.start).valueOf();\n          }\n\n          if (typeof task.endTime === 'undefined' && task.hasOwnProperty('end')) {\n            task.endTime = dayjs(task.end).valueOf();\n          } else if (typeof task.endTime === 'undefined' && task.hasOwnProperty('duration')) {\n            task.endTime = task.startTime + task.duration;\n          }\n\n          if (typeof task.duration === 'undefined' && task.hasOwnProperty('endTime')) {\n            task.duration = task.endTime - task.startTime;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return tasks;\n    },\n\n    /**\n     * Map tasks\n     *\n     * @param {Array} tasks\n     * @param {Object} options\n     */\n    mapTasks: function mapTasks(tasks, options) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = tasks.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              index = _step3$value[0],\n              task = _step3$value[1];\n\n          tasks[index] = _objectSpread({}, task, {\n            id: task[options.taskMapping.id],\n            start: task[options.taskMapping.start],\n            label: task[options.taskMapping.label],\n            duration: task[options.taskMapping.duration],\n            progress: task[options.taskMapping.progress],\n            type: task[options.taskMapping.type],\n            style: task[options.taskMapping.style],\n            collapsed: task[options.taskMapping.collapsed]\n          });\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return tasks;\n    },\n\n    /**\n     * Initialize component\n     */\n    initialize: function initialize() {\n      var _this = this;\n\n      var itsUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var options = mergeDeep({}, this.state.options, getOptions(this.options), this.options);\n      var tasks = this.mapTasks(this.tasks, options);\n\n      if (Object.keys(this.state.dynamicStyle).length === 0) {\n        this.initializeStyle();\n      }\n\n      dayjs.locale(options.locale, null, true);\n      dayjs.locale(options.locale.name);\n\n      if (typeof options.taskList === 'undefined') {\n        options.taskList = {};\n      }\n\n      options.taskList.columns = options.taskList.columns.map(function (column, index) {\n        column.thresholdPercent = 100;\n        column.widthFromPercentage = 0;\n        column.finalWidth = 0;\n\n        if (typeof column.height === 'undefined') {\n          column.height = 0;\n        }\n\n        if (typeof column.style === 'undefined') {\n          column.style = {};\n        }\n\n        column._id = \"\".concat(index, \"-\").concat(column.label);\n        return column;\n      });\n      this.state.options = options;\n      tasks = this.fillTasks(tasks);\n      this.state.tasksById = this.resetTaskTree(tasks);\n      this.state.taskTree = this.makeTaskTree(this.state.rootTask, tasks);\n      this.state.tasks = this.state.taskTree.allChildren.map(function (childId) {\n        return _this.getTask(childId);\n      });\n      this.calculateTaskListColumnsDimensions();\n      this.state.options.scrollBarHeight = this.getScrollBarHeight();\n      this.state.options.outerHeight = this.state.options.height + this.state.options.scrollBarHeight;\n      this.globalOnResize();\n    },\n\n    /**\n     * Initialize style\n     */\n    initializeStyle: function initializeStyle() {\n      this.state.dynamicStyle = mergeDeep({}, prepareStyle(this.dynamicStyle), this.dynamicStyle);\n    },\n\n    /**\n     * Get calendar rows outer height\n     *\n     * @returns {int}\n     */\n    getCalendarHeight: function getCalendarHeight() {\n      return this.state.options.calendar.height + this.state.options.calendar.strokeWidth;\n    },\n\n    /**\n     * Get maximal level of nested task children\n     *\n     * @returns {int}\n     */\n    getMaximalLevel: function getMaximalLevel() {\n      var maximalLevel = 0;\n      this.state.tasks.forEach(function (task) {\n        if (task.parents.length > maximalLevel) {\n          maximalLevel = task.parents.length;\n        }\n      });\n      return maximalLevel - 1;\n    },\n\n    /**\n     * Get maximal expander width - to calculate straight task list text\n     *\n     * @returns {int}\n     */\n    getMaximalExpanderWidth: function getMaximalExpanderWidth() {\n      return this.getMaximalLevel() * this.state.options.taskList.expander.padding + this.state.options.taskList.expander.margin;\n    },\n\n    /**\n     * Synchronize scrollTop property when row height is changed\n     */\n    syncScrollTop: function syncScrollTop() {\n      if (this.state.refs.taskListItems && this.state.refs.chartGraph.scrollTop !== this.state.refs.taskListItems.scrollTop) {\n        this.state.options.scroll.top = this.state.refs.taskListItems.scrollTop = this.state.refs.chartScrollContainerVertical.scrollTop = this.state.refs.chartGraph.scrollTop;\n      }\n    },\n\n    /**\n     * Calculate task list columns dimensions\n     */\n    calculateTaskListColumnsDimensions: function calculateTaskListColumnsDimensions() {\n      var final = 0;\n      var percentage = 0;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.state.options.taskList.columns[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var column = _step4.value;\n\n          if (column.expander) {\n            column.widthFromPercentage = (this.getMaximalExpanderWidth() + column.width) / 100 * this.state.options.taskList.percent;\n          } else {\n            column.widthFromPercentage = column.width / 100 * this.state.options.taskList.percent;\n          }\n\n          percentage += column.widthFromPercentage;\n          column.finalWidth = column.thresholdPercent * column.widthFromPercentage / 100;\n          final += column.finalWidth;\n          column.height = this.getTaskHeight() - this.style['grid-line-horizontal']['stroke-width'];\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      this.state.options.taskList.widthFromPercentage = percentage;\n      this.state.options.taskList.finalWidth = final;\n    },\n\n    /**\n     * Reset task tree - which is used to create tree like structure inside task list\n     */\n    resetTaskTree: function resetTaskTree(tasks) {\n      this.$set(this.state, 'rootTask', {\n        id: null,\n        label: 'root',\n        children: [],\n        allChildren: [],\n        parents: [],\n        parent: null,\n        __root: true\n      });\n      var tasksById = {};\n\n      for (var i = 0, len = tasks.length; i < len; i++) {\n        var current = tasks[i];\n        current.children = [];\n        current.allChildren = [];\n        current.parent = null;\n        current.parents = [];\n        tasksById[current.id] = current;\n      }\n\n      return tasksById;\n    },\n\n    /**\n     * Make task tree, after reset - look above\n     *\n     * @param {object} task\n     * @returns {object} tasks with children and parents\n     */\n    makeTaskTree: function makeTaskTree(task, tasks) {\n      var _this2 = this;\n\n      var _loop = function _loop(i, len) {\n        var current = tasks[i];\n\n        if (current.parentId === task.id) {\n          if (task.parents.length) {\n            task.parents.forEach(function (parent) {\n              return current.parents.push(parent);\n            });\n          }\n\n          if (!task.propertyIsEnumerable('__root')) {\n            current.parents.push(task.id);\n            current.parent = task.id;\n          } else {\n            current.parents = [];\n            current.parent = null;\n          }\n\n          current = _this2.makeTaskTree(current, tasks);\n          task.allChildren.push(current.id);\n          task.children.push(current.id);\n          current.allChildren.forEach(function (childId) {\n            return task.allChildren.push(childId);\n          });\n        }\n      };\n\n      for (var i = 0, len = tasks.length; i < len; i++) {\n        _loop(i, len);\n      }\n\n      return task;\n    },\n\n    /**\n     * Get task by id\n     *\n     * @param {any} taskId\n     * @returns {object|null} task\n     */\n    getTask: function getTask(taskId) {\n      if (typeof this.state.tasksById[taskId] !== 'undefined') {\n        return this.state.tasksById[taskId];\n      }\n\n      return null;\n    },\n\n    /**\n     * Get children tasks for specified taskId\n     *\n     * @param {any} taskId\n     * @returns {array} children\n     */\n    getChildren: function getChildren(taskId) {\n      return this.state.tasks.filter(function (task) {\n        return task.parent === taskId;\n      });\n    },\n\n    /**\n     * Is task visible\n     *\n     * @param {Number|String|Task} task\n     */\n    isTaskVisible: function isTaskVisible(task) {\n      if (typeof task === 'number' || typeof task === 'string') {\n        task = this.getTask(task);\n      }\n\n      for (var i = 0, len = task.parents.length; i < len; i++) {\n        if (this.getTask(task.parents[i]).collapsed) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Get svg\n     *\n     * @returns {string} html svg image of gantt\n     */\n    getSVG: function getSVG() {\n      return this.state.options.mainView.outerHTML;\n    },\n\n    /**\n     * Get image\n     *\n     * @param {string} type image format\n     * @returns {Promise} when resolved returns base64 image string of gantt\n     */\n    getImage: function getImage() {\n      var _this3 = this;\n\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';\n      return new Promise(function (resolve) {\n        var img = new Image();\n\n        img.onload = function () {\n          var canvas = document.createElement('canvas');\n          canvas.width = _this3.state.options.mainView.clientWidth;\n          canvas.height = _this3.state.options.rowsHeight;\n          canvas.getContext('2d').drawImage(img, 0, 0);\n          resolve(canvas.toDataURL(type));\n        };\n\n        img.src = 'data:image/svg+xml,' + encodeURIComponent(_this3.getSVG());\n      });\n    },\n\n    /**\n     * Get gantt total height\n     *\n     * @returns {number}\n     */\n    getHeight: function getHeight(visibleTasks) {\n      var outer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var height = visibleTasks.length * (this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2) + this.state.options.calendar.height + this.state.options.calendar.strokeWidth + this.state.options.calendar.gap;\n\n      if (outer) {\n        height += this.state.options.scrollBarHeight;\n      }\n\n      return height;\n    },\n\n    /**\n     * Get one task height\n     *\n     * @returns {number}\n     */\n    getTaskHeight: function getTaskHeight() {\n      var withStroke = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (withStroke) {\n        return this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2 + this.style['grid-line-horizontal']['stroke-width'];\n      }\n\n      return this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2;\n    },\n\n    /**\n     * Get specified tasks height\n     *\n     * @returns {number}\n     */\n    getTasksHeight: function getTasksHeight(visibleTasks) {\n      return visibleTasks.length * this.getTaskHeight();\n    },\n\n    /**\n     * Convert time (in milliseconds) to pixel offset inside chart\n     *\n     * @param {int} ms\n     * @returns {number}\n     */\n    timeToPixelOffsetX: function timeToPixelOffsetX(ms) {\n      var x = ms - this.state.options.times.firstTime;\n\n      if (x) {\n        x = x / this.state.options.times.timePerPixel;\n      }\n\n      return x;\n    },\n\n    /**\n     * Convert pixel offset inside chart to corresponding time offset in milliseconds\n     *\n     * @param {number} pixelOffsetX\n     * @returns {int} milliseconds\n     */\n    pixelOffsetXToTime: function pixelOffsetXToTime(pixelOffsetX) {\n      var offset = pixelOffsetX + this.style['grid-line-vertical']['stroke-width'] / 2;\n      return offset * this.state.options.times.timePerPixel + this.state.options.times.firstTime;\n    },\n\n    /**\n     * Determine if element is inside current view port\n     *\n     * @param {number} x - element placement\n     * @param {number} width - element width\n     * @param {int} buffer - or threshold, if element is outside viewport but offset from view port is below this value return true\n     * @returns {boolean}\n     */\n    isInsideViewPort: function isInsideViewPort(x, width) {\n      var buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5000;\n      return x + width + buffer >= this.state.options.scroll.chart.left && x - buffer <= this.state.options.scroll.chart.right || x - buffer <= this.state.options.scroll.chart.left && x + width + buffer >= this.state.options.scroll.chart.right;\n    },\n\n    /**\n     * Chart scroll event handler\n     *\n     * @param {event} ev\n     */\n    onScrollChart: function onScrollChart(ev) {\n      this._onScrollChart(this.state.refs.chartScrollContainerHorizontal.scrollLeft, this.state.refs.chartScrollContainerVertical.scrollTop);\n    },\n\n    /**\n     * After same as above but with different arguments - normalized\n     *\n     * @param {number} left\n     * @param {number} top\n     */\n    _onScrollChart: function _onScrollChart(left, top) {\n      if (this.state.options.scroll.chart.left === left && this.state.options.scroll.chart.top === top) {\n        return;\n      }\n\n      var chartContainerWidth = this.state.refs.chartContainer.clientWidth;\n      this.state.options.scroll.chart.left = left;\n      this.state.options.scroll.chart.right = left + chartContainerWidth;\n      this.state.options.scroll.chart.percent = left / this.state.options.times.totalViewDurationPx * 100;\n      this.state.options.scroll.chart.top = top;\n      this.state.options.scroll.chart.time = this.pixelOffsetXToTime(left);\n      this.state.options.scroll.chart.timeCenter = this.pixelOffsetXToTime(left + chartContainerWidth / 2);\n      this.state.options.scroll.chart.dateTime.left = dayjs(this.state.options.scroll.chart.time).valueOf();\n      this.state.options.scroll.chart.dateTime.right = dayjs(this.pixelOffsetXToTime(left + this.state.refs.chart.clientWidth)).valueOf();\n      this.scrollTo(left, top);\n    },\n\n    /**\n     * Scroll current chart to specified time (in milliseconds)\n     *\n     * @param {int} time\n     */\n    scrollToTime: function scrollToTime(time) {\n      var pos = this.timeToPixelOffsetX(time);\n      var chartContainerWidth = this.state.refs.chartContainer.clientWidth;\n      pos = pos - chartContainerWidth / 2;\n\n      if (pos > this.state.options.width) {\n        pos = this.state.options.width - chartContainerWidth;\n      }\n\n      this.scrollTo(pos);\n    },\n\n    /**\n     * Scroll chart or task list to specified pixel values\n     *\n     * @param {number|null} left\n     * @param {number|null} top\n     */\n    scrollTo: function scrollTo() {\n      var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (left !== null) {\n        this.state.refs.chartCalendarContainer.scrollLeft = left;\n        this.state.refs.chartGraphContainer.scrollLeft = left;\n        this.state.refs.chartScrollContainerHorizontal.scrollLeft = left;\n        this.state.options.scroll.left = left;\n      }\n\n      if (top !== null) {\n        this.state.refs.chartScrollContainerVertical.scrollTop = top;\n        this.state.refs.chartGraph.scrollTop = top;\n        this.state.refs.taskListItems.scrollTop = top;\n        this.state.options.scroll.top = top;\n        this.syncScrollTop();\n      }\n    },\n\n    /**\n     * After some actions like time zoom change we need to recompensate scroll position\n     * so as a result everything will be in same place\n     */\n    fixScrollPos: function fixScrollPos() {\n      this.scrollToTime(this.state.options.scroll.chart.timeCenter);\n    },\n\n    /**\n     * Mouse wheel event handler\n     */\n    onWheelChart: function onWheelChart(ev) {\n      if (!ev.shiftKey && ev.deltaX === 0) {\n        var top = this.state.options.scroll.top + ev.deltaY;\n        var chartClientHeight = this.state.options.rowsHeight;\n        var scrollHeight = this.state.refs.chartGraph.scrollHeight - chartClientHeight;\n\n        if (top < 0) {\n          top = 0;\n        } else if (top > scrollHeight) {\n          top = scrollHeight;\n        }\n\n        this.scrollTo(null, top);\n      } else if (ev.shiftKey && ev.deltaX === 0) {\n        var left = this.state.options.scroll.left + ev.deltaY;\n        var chartClientWidth = this.state.refs.chartScrollContainerHorizontal.clientWidth;\n        var scrollWidth = this.state.refs.chartScrollContainerHorizontal.scrollWidth - chartClientWidth;\n\n        if (left < 0) {\n          left = 0;\n        } else if (left > scrollWidth) {\n          left = scrollWidth;\n        }\n\n        this.scrollTo(left);\n      } else {\n        var _left = this.state.options.scroll.left + ev.deltaX;\n\n        var _chartClientWidth = this.state.refs.chartScrollContainerHorizontal.clientWidth;\n\n        var _scrollWidth = this.state.refs.chartScrollContainerHorizontal.scrollWidth - _chartClientWidth;\n\n        if (_left < 0) {\n          _left = 0;\n        } else if (_left > _scrollWidth) {\n          _left = _scrollWidth;\n        }\n\n        this.scrollTo(_left);\n      }\n    },\n\n    /**\n     * Time zoom change event handler\n     */\n    onTimeZoomChange: function onTimeZoomChange(timeZoom) {\n      this.state.options.times.timeZoom = timeZoom;\n      this.recalculateTimes();\n      this.calculateSteps();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Row height change event handler\n     */\n    onRowHeightChange: function onRowHeightChange(height) {\n      this.state.options.row.height = height;\n      this.calculateTaskListColumnsDimensions();\n      this.syncScrollTop();\n    },\n\n    /**\n     * Scope change event handler\n     */\n    onScopeChange: function onScopeChange(value) {\n      this.state.options.scope.before = value;\n      this.state.options.scope.after = value;\n      this.initTimes();\n      this.calculateSteps();\n      this.computeCalendarWidths();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Task list width change event handler\n     */\n    onTaskListWidthChange: function onTaskListWidthChange(value) {\n      this.state.options.taskList.percent = value;\n      this.calculateTaskListColumnsDimensions();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Task list column width change event handler\n     */\n    onTaskListColumnWidthChange: function onTaskListColumnWidthChange() {\n      this.calculateTaskListColumnsDimensions();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Listen to specified event names\n     */\n    initializeEvents: function initializeEvents() {\n      this.$on('chart-scroll-horizontal', this.onScrollChart);\n      this.$on('chart-scroll-vertical', this.onScrollChart);\n      this.$on('chart-wheel', this.onWheelChart);\n      this.$on('times-timeZoom-change', this.onTimeZoomChange);\n      this.$on('row-height-change', this.onRowHeightChange);\n      this.$on('scope-change', this.onScopeChange);\n      this.$on('taskList-width-change', this.onTaskListWidthChange);\n      this.$on('taskList-column-width-change', this.onTaskListColumnWidthChange);\n    },\n\n    /**\n     * When some action was performed (scale change for example) - recalculate time variables\n     */\n    recalculateTimes: function recalculateTimes() {\n      var max = this.state.options.times.timeScale * 60;\n      var min = this.state.options.times.timeScale;\n      var steps = max / min;\n      var percent = this.state.options.times.timeZoom / 100;\n      this.state.options.times.timePerPixel = this.state.options.times.timeScale * steps * percent + Math.pow(2, this.state.options.times.timeZoom);\n      this.state.options.times.totalViewDurationMs = dayjs(this.state.options.times.lastTime).diff(this.state.options.times.firstTime, 'milliseconds');\n      this.state.options.times.totalViewDurationPx = this.state.options.times.totalViewDurationMs / this.state.options.times.timePerPixel;\n      this.state.options.width = this.state.options.times.totalViewDurationPx + this.style['grid-line-vertical']['stroke-width'];\n    },\n\n    /**\n     * Initialize time variables\n     */\n    initTimes: function initTimes() {\n      this.state.options.times.firstTime = dayjs(this.state.options.times.firstTaskTime).locale(this.state.options.locale.name).startOf('day').subtract(this.state.options.scope.before, 'days').startOf('day').valueOf();\n      this.state.options.times.lastTime = dayjs(this.state.options.times.lastTaskTime).locale(this.state.options.locale.name).endOf('day').add(this.state.options.scope.after, 'days').endOf('day').valueOf();\n      this.recalculateTimes();\n    },\n\n    /**\n     * Calculate steps\n     * Steps are days by default\n     * Each step contain information about time offset and pixel offset of this time inside gantt chart\n     */\n    calculateSteps: function calculateSteps() {\n      var steps = [];\n      var lastMs = dayjs(this.state.options.times.lastTime).valueOf();\n      var currentDate = dayjs(this.state.options.times.firstTime);\n      steps.push({\n        time: currentDate.valueOf(),\n        offset: {\n          ms: 0,\n          px: 0\n        }\n      });\n\n      for (var _currentDate = dayjs(this.state.options.times.firstTime).add(1, this.state.options.times.stepDuration).startOf('day'); _currentDate.valueOf() <= lastMs; _currentDate = _currentDate.add(1, this.state.options.times.stepDuration).startOf('day')) {\n        var offsetMs = _currentDate.diff(this.state.options.times.firstTime, 'milliseconds');\n\n        var offsetPx = offsetMs / this.state.options.times.timePerPixel;\n        var step = {\n          time: _currentDate.valueOf(),\n          offset: {\n            ms: offsetMs,\n            px: offsetPx\n          }\n        };\n        var previousStep = steps[steps.length - 1];\n        previousStep.width = {\n          ms: offsetMs - previousStep.offset.ms,\n          px: offsetPx - previousStep.offset.px\n        };\n        steps.push(step);\n      }\n\n      var lastStep = steps[steps.length - 1];\n      lastStep.width = {\n        ms: this.state.options.times.totalViewDurationMs - lastStep.offset.ms,\n        px: this.state.options.times.totalViewDurationPx - lastStep.offset.px\n      };\n      this.state.options.times.steps = steps;\n    },\n\n    /**\n     * Calculate calendar widths - when scale was changed for example\n     */\n    computeCalendarWidths: function computeCalendarWidths() {\n      this.computeDayWidths();\n      this.computeHourWidths();\n      this.computeMonthWidths();\n    },\n\n    /**\n     * Compute width of calendar hours column widths basing on text widths\n     */\n    computeHourWidths: function computeHourWidths() {\n      var style = _objectSpread({}, this.style['calendar-row-text'], this.style['calendar-row-text--hour']);\n\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      var localeName = this.state.options.locale.name;\n      var currentDate = dayjs('2018-01-01T00:00:00').locale(localeName); // any date will be good for hours\n\n      var maxWidths = this.state.options.calendar.hour.maxWidths;\n\n      if (maxWidths.length) {\n        return;\n      }\n\n      for (var formatName in this.state.options.calendar.hour.format) {\n        maxWidths[formatName] = 0;\n      }\n\n      for (var hour = 0; hour < 24; hour++) {\n        var widths = {\n          hour: hour\n        };\n\n        for (var _formatName in this.state.options.calendar.hour.format) {\n          var hourFormatted = this.state.options.calendar.hour.format[_formatName](currentDate);\n\n          this.state.options.calendar.hour.formatted[_formatName].push(hourFormatted);\n\n          widths[_formatName] = this.state.ctx.measureText(hourFormatted).width;\n        }\n\n        this.state.options.calendar.hour.widths.push(widths);\n\n        for (var _formatName2 in this.state.options.calendar.hour.format) {\n          if (widths[_formatName2] > maxWidths[_formatName2]) {\n            maxWidths[_formatName2] = widths[_formatName2];\n          }\n        }\n\n        currentDate = currentDate.add(1, 'hour');\n      }\n    },\n\n    /**\n     * Compute calendar days column widths basing on text widths\n     */\n    computeDayWidths: function computeDayWidths() {\n      var _this4 = this;\n\n      var style = _objectSpread({}, this.style['calendar-row-text'], this.style['calendar-row-text--day']);\n\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      var localeName = this.state.options.locale.name;\n      var currentDate = dayjs(this.state.options.times.steps[0].time).locale(localeName);\n      var maxWidths = this.state.options.calendar.day.maxWidths;\n      this.state.options.calendar.day.widths = [];\n      Object.keys(this.state.options.calendar.day.format).forEach(function (formatName) {\n        maxWidths[formatName] = 0;\n      });\n\n      var _loop2 = function _loop2(day, daysLen) {\n        var widths = {\n          day: day\n        };\n        Object.keys(_this4.state.options.calendar.day.format).forEach(function (formatName) {\n          widths[formatName] = _this4.state.ctx.measureText(_this4.state.options.calendar.day.format[formatName](currentDate)).width;\n        });\n\n        _this4.state.options.calendar.day.widths.push(widths);\n\n        Object.keys(_this4.state.options.calendar.day.format).forEach(function (formatName) {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        });\n        currentDate = currentDate.add(1, 'day');\n      };\n\n      for (var day = 0, daysLen = this.state.options.times.steps.length; day < daysLen; day++) {\n        _loop2(day, daysLen);\n      }\n    },\n\n    /**\n     * Months count\n     *\n     * @description Returns number of different months in specified time range\n     *\n     * @param {number} fromTime - date in ms\n     * @param {number} toTime - date in ms\n     *\n     * @returns {number} different months count\n     */\n    monthsCount: function monthsCount(fromTime, toTime) {\n      if (fromTime > toTime) {\n        return 0;\n      }\n\n      var currentMonth = dayjs(fromTime);\n      var previousMonth = currentMonth.clone();\n      var monthsCount = 1;\n\n      while (currentMonth.valueOf() <= toTime) {\n        currentMonth = currentMonth.add(1, 'day');\n\n        if (previousMonth.month() !== currentMonth.month()) {\n          monthsCount++;\n        }\n\n        previousMonth = currentMonth.clone();\n      }\n\n      return monthsCount;\n    },\n\n    /**\n     * Compute month calendar columns widths basing on text widths\n     */\n    computeMonthWidths: function computeMonthWidths() {\n      var _this5 = this;\n\n      var style = _objectSpread({}, this.style['calendar-row-text'], this.style['calendar-row-text--month']);\n\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      var maxWidths = this.state.options.calendar.month.maxWidths;\n      this.state.options.calendar.month.widths = [];\n      Object.keys(this.state.options.calendar.month.format).forEach(function (formatName) {\n        maxWidths[formatName] = 0;\n      });\n      var localeName = this.state.options.locale.name;\n      var currentDate = dayjs(this.state.options.times.firstTime).locale(localeName);\n      var monthsCount = this.monthsCount(this.state.options.times.firstTime, this.state.options.times.lastTime);\n\n      var _loop3 = function _loop3(month) {\n        var widths = {\n          month: month\n        };\n        Object.keys(_this5.state.options.calendar.month.format).forEach(function (formatName) {\n          widths[formatName] = _this5.state.ctx.measureText(_this5.state.options.calendar.month.format[formatName](currentDate)).width;\n        });\n\n        _this5.state.options.calendar.month.widths.push(widths);\n\n        Object.keys(_this5.state.options.calendar.month.format).forEach(function (formatName) {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        });\n        currentDate = currentDate.add(1, 'month');\n      };\n\n      for (var month = 0; month < monthsCount; month++) {\n        _loop3(month);\n      }\n    },\n\n    /**\n     * Prepare time and date variables for gantt\n     */\n    prepareDates: function prepareDates() {\n      var firstTaskTime = Number.MAX_SAFE_INTEGER;\n      var lastTaskTime = 0;\n\n      for (var index = 0, len = this.state.tasks.length; index < len; index++) {\n        var task = this.state.tasks[index];\n\n        if (task.startTime < firstTaskTime) {\n          firstTaskTime = task.startTime;\n        }\n\n        if (task.startTime + task.duration > lastTaskTime) {\n          lastTaskTime = task.startTime + task.duration;\n        }\n      }\n\n      this.state.options.times.firstTaskTime = firstTaskTime;\n      this.state.options.times.lastTaskTime = lastTaskTime;\n      this.state.options.times.firstTime = dayjs(firstTaskTime).locale(this.state.options.locale.name).startOf('day').subtract(this.state.options.scope.before, 'days').startOf('day').valueOf();\n      this.state.options.times.lastTime = dayjs(lastTaskTime).locale(this.state.options.locale.name).endOf('day').add(this.state.options.scope.after, 'days').endOf('day').valueOf();\n    },\n\n    /**\n     * Setup and calculate everything\n     */\n    setup: function setup() {\n      var itsUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      this.initialize(itsUpdate);\n      this.prepareDates();\n      this.initTimes();\n      this.calculateSteps();\n      this.computeCalendarWidths();\n      this.state.options.taskList.width = this.state.options.taskList.columns.reduce(function (prev, current) {\n        return {\n          width: prev.width + current.width\n        };\n      }, {\n        width: 0\n      }).width;\n    },\n\n    /**\n     * Global resize event (from window.addEventListener)\n     */\n    globalOnResize: function globalOnResize() {\n      if (typeof this.$el === 'undefined' || !this.$el) {\n        return;\n      }\n\n      this.state.options.clientWidth = this.$el.clientWidth;\n\n      if (this.state.options.taskList.widthFromPercentage > this.state.options.clientWidth / 100 * this.state.options.taskList.widthThreshold) {\n        var diff = this.state.options.taskList.widthFromPercentage - this.state.options.clientWidth / 100 * this.state.options.taskList.widthThreshold;\n        var diffPercent = 100 - diff / this.state.options.taskList.widthFromPercentage * 100;\n\n        if (diffPercent < 0) {\n          diffPercent = 0;\n        }\n\n        this.state.options.taskList.columns.forEach(function (column) {\n          column.thresholdPercent = diffPercent;\n        });\n      } else {\n        this.state.options.taskList.columns.forEach(function (column) {\n          column.thresholdPercent = 100;\n        });\n      }\n\n      this.calculateTaskListColumnsDimensions();\n      this.$emit('calendar-recalculate');\n      this.syncScrollTop();\n    }\n  },\n  computed: {\n    /**\n     * Get visible tasks\n     * Very important method which will bring us only those tasks that are visible inside gantt chart\n     * For example when task is collapsed - children of this task are not visible - we should not render them\n     */\n    visibleTasks: function visibleTasks() {\n      var _this6 = this;\n\n      var visibleTasks = this.state.tasks.filter(function (task) {\n        return _this6.isTaskVisible(task);\n      });\n      var maxRows = visibleTasks.slice(0, this.state.options.maxRows);\n      this.state.options.rowsHeight = this.getTasksHeight(maxRows);\n      var heightCompensation = 0;\n\n      if (this.state.options.maxHeight && this.state.options.rowsHeight > this.state.options.maxHeight) {\n        heightCompensation = this.state.options.rowsHeight - this.state.options.maxHeight;\n        this.state.options.rowsHeight = this.state.options.maxHeight;\n      }\n\n      this.state.options.height = this.getHeight(maxRows) - heightCompensation;\n      this.state.options.allVisibleTasksHeight = this.getTasksHeight(visibleTasks);\n      this.state.options.outerHeight = this.getHeight(maxRows, true) - heightCompensation;\n      var len = visibleTasks.length;\n\n      for (var index = 0; index < len; index++) {\n        var task = visibleTasks[index];\n        task.width = task.duration / this.state.options.times.timePerPixel - this.style['grid-line-vertical']['stroke-width'];\n\n        if (task.width < 0) {\n          task.width = 0;\n        }\n\n        task.height = this.state.options.row.height;\n        task.x = this.timeToPixelOffsetX(task.startTime);\n        task.y = (this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2) * index + this.state.options.chart.grid.horizontal.gap;\n      }\n\n      return visibleTasks;\n    },\n\n    /**\n     * Style shortcut\n     */\n    style: function style() {\n      return this.state.dynamicStyle;\n    },\n\n    /**\n     * Get columns and compute dimensions on the fly\n     */\n    getTaskListColumns: function getTaskListColumns() {\n      this.calculateTaskListColumnsDimensions();\n      return this.state.options.taskList.columns;\n    },\n\n    /**\n     * Tasks used for communicate with parent component\n     */\n    outputTasks: function outputTasks() {\n      return this.state.tasks;\n    },\n\n    /**\n     * Options used to communicate with parent component\n     */\n    outputOptions: function outputOptions() {\n      return this.state.options;\n    }\n  },\n\n  /**\n   * Watch tasks after gantt instance is created and react when we have new kids on the block\n   */\n  created: function created() {\n    var _this7 = this;\n\n    this.initializeEvents();\n    this.setup();\n    this.state.unwatchTasks = this.$watch('tasks', function (tasks) {\n      var notEqual = notEqualDeep(tasks, _this7.outputTasks);\n\n      if (notEqual) {\n        _this7.setup('tasks');\n      }\n    }, {\n      deep: true\n    });\n    this.state.unwatchOptions = this.$watch('options', function (opts) {\n      var notEqual = notEqualDeep(opts, _this7.outputOptions);\n\n      if (notEqual) {\n        _this7.setup('options');\n      }\n    }, {\n      deep: true\n    });\n    this.state.unwatchStyle = this.$watch('dynamicStyle', function (style) {\n      var notEqual = notEqualDeep(style, _this7.dynamicStyle);\n\n      if (notEqual) {\n        _this7.initializeStyle();\n      }\n    }, {\n      deep: true,\n      immediate: true\n    });\n    this.state.unwatchOutputTasks = this.$watch('outputTasks', function (tasks) {\n      _this7.$emit('tasks-changed', tasks.map(function (task) {\n        return task;\n      }));\n    }, {\n      deep: true\n    });\n    this.state.unwatchOutputOptions = this.$watch('outputOptions', function (options) {\n      _this7.$emit('options-changed', mergeDeep({}, options));\n    }, {\n      deep: true\n    });\n    this.state.unwatchOutputStyle = this.$watch('style', function (style) {\n      _this7.$emit('dynamic-style-changed', mergeDeep({}, style));\n    }, {\n      deep: true\n    });\n    this.$root.$emit('gantt-elastic-created', this);\n    this.$emit('created', this);\n  },\n\n  /**\n   * Emit before-mount event\n   */\n  beforeMount: function beforeMount() {\n    this.$emit('before-mount', this);\n  },\n\n  /**\n   * Emit ready/mounted events and deliver this gantt instance to outside world when needed\n   */\n  mounted: function mounted() {\n    var _this8 = this;\n\n    this.state.options.clientWidth = this.$el.clientWidth;\n    this.state.resizeObserver = new ResizeObserver(function (entries, observer) {\n      _this8.globalOnResize();\n    });\n    this.state.resizeObserver.observe(this.$el.parentNode);\n    this.globalOnResize();\n    this.$emit('ready', this);\n    this.$root.$emit('gantt-elastic-mounted', this);\n    this.$emit('mounted', this);\n    this.$root.$emit('gantt-elastic-ready', this);\n  },\n\n  /**\n   * Emit event when data was changed and before update (you can cleanup dom events here for example)\n   */\n  beforeUpdate: function beforeUpdate() {\n    this.$emit('before-update');\n  },\n\n  /**\n   * Emit event when gantt-elastic view was updated\n   */\n  updated: function updated() {\n    var _this9 = this;\n\n    this.$nextTick(function () {\n      _this9.$emit('updated');\n    });\n  },\n\n  /**\n   * Before destroy event - clean up\n   */\n  beforeDestroy: function beforeDestroy() {\n    this.state.resizeObserver.unobserve(this.$el.parentNode);\n    this.state.unwatchTasks();\n    this.state.unwatchOptions();\n    this.state.unwatchStyle();\n    this.state.unwatchOutputTasks();\n    this.state.unwatchOutputOptions();\n    this.state.unwatchOutputStyle();\n    this.$emit('before-destroy');\n  },\n\n  /**\n   * Emit event after gantt-elastic was destroyed\n   */\n  destroyed: function destroyed() {\n    this.$emit('destroyed');\n  }\n};\nexport default GanttElastic;",{"version":3,"sources":["GanttElastic.vue"],"names":[],"mappings":"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","sourcesContent":["<!--\n/**\n * @fileoverview GanttElastic component\n * @license MIT\n * @author Rafal Pospiech <neuronet.io@gmail.com>\n * @package GanttElastic\n */\n-->\n<template>\n  <div class=\"gantt-elastic\" style=\"width:100%\">\n    <slot name=\"header\"></slot>\n    <main-view ref=\"mainView\"></main-view>\n    <slot name=\"footer\"></slot>\n  </div>\n</template>\n\n<script>\nimport VueInstance from 'vue';\nimport dayjs from 'dayjs';\nimport MainView from './components/MainView.vue';\nimport getStyle from './style.js';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nconst ctx = document.createElement('canvas').getContext('2d');\nlet VueInst = VueInstance;\nfunction initVue() {\n  if (typeof Vue !== 'undefined' && typeof VueInst === 'undefined') {\n    VueInst = Vue;\n  }\n}\ninitVue();\n\nlet hourWidthCache = null;\n\n/**\n * Helper function to fill out empty options in user settings\n *\n * @param {object} userOptions - initial user options that will merge with those below\n * @returns {object} merged options\n */\nfunction getOptions(userOptions) {\n  let localeName = 'en';\n  if (typeof userOptions.locale !== 'undefined' && typeof userOptions.locale.name !== 'undefined') {\n    localeName = userOptions.locale.name;\n  }\n  return {\n    slots: {\n      header: {}\n    },\n    taskMapping: {\n      //*\n      id: 'id',\n      start: 'start',\n      label: 'label',\n      duration: 'duration',\n      progress: 'progress',\n      type: 'type',\n      style: 'style',\n      collapsed: 'collapsed'\n    },\n    width: 0,\n    height: 0,\n    clientWidth: 0,\n    outerHeight: 0,\n    rowsHeight: 0,\n    allVisibleTasksHeight: 0,\n    scroll: {\n      scrolling: false,\n      dragXMoveMultiplier: 3, //*\n      dragYMoveMultiplier: 2, //*\n      top: 0,\n      taskList: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      },\n      chart: {\n        left: 0,\n        right: 0,\n        percent: 0,\n        timePercent: 0,\n        top: 0,\n        bottom: 0,\n        time: 0,\n        timeCenter: 0,\n        dateTime: {\n          left: '',\n          right: ''\n        }\n      }\n    },\n    scope: {\n      //*\n      before: 1,\n      after: 1\n    },\n    times: {\n      timeScale: 60 * 1000,\n      timeZoom: 17, //*\n      timePerPixel: 0,\n      firstTime: null,\n      lastTime: null,\n      firstTaskTime: 0,\n      lastTaskTime: 0,\n      totalViewDurationMs: 0,\n      totalViewDurationPx: 0,\n      stepDuration: 'day',\n      steps: []\n    },\n    row: {\n      height: 24 //*\n    },\n    maxRows: 20, //*\n    maxHeight: 0, //*\n    chart: {\n      grid: {\n        horizontal: {\n          gap: 6 //*\n        }\n      },\n      progress: {\n        width: 20, //*\n        height: 6, //*\n        pattern: true,\n        bar: false\n      },\n      text: {\n        offset: 4, //*\n        xPadding: 10, //*\n        display: true //*\n      },\n      expander: {\n        type: 'chart',\n        display: false, //*\n        displayIfTaskListHidden: true, //*\n        offset: 4, //*\n        size: 18\n      }\n    },\n    taskList: {\n      display: true, //*\n      resizeAfterThreshold: true, //*\n      widthThreshold: 75, //*\n      columns: [\n        //*\n        {\n          id: 0,\n          label: 'ID',\n          value: 'id',\n          width: 40\n        }\n      ],\n      percent: 100, //*\n      width: 0,\n      finalWidth: 0,\n      widthFromPercentage: 0,\n      minWidth: 18,\n      expander: {\n        type: 'task-list',\n        size: 16,\n        columnWidth: 24,\n        padding: 16,\n        margin: 10,\n        straight: false\n      }\n    },\n    calendar: {\n      workingDays: [1, 2, 3, 4, 5], //*\n      gap: 6, //*\n      height: 0,\n      strokeWidth: 1,\n      hour: {\n        height: 20, //*\n        display: true, //*\n        widths: [],\n        maxWidths: { short: 0, medium: 0, long: 0 },\n        formatted: {\n          long: [],\n          medium: [],\n          short: []\n        },\n        format: {\n          //*\n          long(date) {\n            return date.format('HH:mm');\n          },\n          medium(date) {\n            return date.format('HH:mm');\n          },\n          short(date) {\n            return date.format('HH');\n          }\n        }\n      },\n      day: {\n        height: 20, //*\n        display: true, //*\n        widths: [],\n        maxWidths: { short: 0, medium: 0, long: 0 },\n        format: {\n          long(date) {\n            return date.format('DD dddd');\n          },\n          medium(date) {\n            return date.format('DD ddd');\n          },\n          short(date) {\n            return date.format('DD');\n          }\n        }\n      },\n      month: {\n        height: 20, //*\n        display: true, //*\n        widths: [],\n        maxWidths: { short: 0, medium: 0, long: 0 },\n        format: {\n          //*\n          short(date) {\n            return date.format('MM');\n          },\n          medium(date) {\n            return date.format(\"MMM 'YY\");\n          },\n          long(date) {\n            return date.format('MMMM YYYY');\n          }\n        }\n      }\n    },\n    locale: {\n      //*\n      name: 'en',\n      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n      weekStart: 1,\n      relativeTime: {\n        future: 'in %s',\n        past: '%s ago',\n        s: 'a few seconds',\n        m: 'a minute',\n        mm: '%d minutes',\n        h: 'an hour',\n        hh: '%d hours',\n        d: 'a day',\n        dd: '%d days',\n        M: 'a month',\n        MM: '%d months',\n        y: 'a year',\n        yy: '%d years'\n      },\n      formats: {\n        LT: 'HH:mm',\n        LTS: 'HH:mm:ss',\n        L: 'DD/MM/YYYY',\n        LL: 'D MMMM YYYY',\n        LLL: 'D MMMM YYYY HH:mm',\n        LLLL: 'dddd, D MMMM YYYY HH:mm'\n      },\n      ordinal: n => {\n        const s = ['th', 'st', 'nd', 'rd'];\n        const v = n % 100;\n        return `[${n}${s[(v - 20) % 10] || s[v] || s[0]}]`;\n      }\n    }\n  };\n}\n\n/**\n * Prepare style\n *\n * @returns {object}\n */\nfunction prepareStyle(userStyle) {\n  let fontSize = '12px';\n  let fontFamily = window\n    .getComputedStyle(document.body)\n    .getPropertyValue('font-family')\n    .toString();\n  if (typeof userStyle !== 'undefined') {\n    if (typeof userStyle.fontSize !== 'undefined') {\n      fontSize = userOptions.fontSize;\n    }\n    if (typeof userStyle.fontFamily !== 'undefined') {\n      fontFamily = userStyle.fontFamily;\n    }\n  }\n  return getStyle(fontSize, fontFamily);\n}\n\n/**\n * Helper function to determine if specified variable is an object\n *\n * @param {any} item\n *\n * @returns {boolean}\n */\nfunction isObject(item) {\n  return (\n    item &&\n    typeof item === 'object' &&\n    !Array.isArray(item) &&\n    !(item instanceof HTMLElement) &&\n    !(item instanceof CanvasRenderingContext2D) &&\n    typeof item !== 'function'\n  );\n}\n\n/**\n * Helper function which will merge objects recursively - creating brand new one - like clone\n *\n * @param {object} target\n * @params {object} sources\n *\n * @returns {object}\n */\nexport function mergeDeep(target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (typeof target[key] === 'undefined') {\n          target[key] = {};\n        }\n        target[key] = mergeDeep(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        target[key] = [];\n        for (let item of source[key]) {\n          if (isObject(item)) {\n            target[key].push(mergeDeep({}, item));\n            continue;\n          }\n          target[key].push(item);\n        }\n      } else {\n        target[key] = source[key];\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n}\n\n/**\n * Detect if object or array is observable\n *\n * @param {object|array} obj\n *\n * @returns {boolean}\n */\nfunction isObservable(obj) {\n  return typeof obj === 'object' && obj.hasOwnProperty('__ob__');\n}\n\n/**\n * Same as above but with reactivity in mind\n *\n * @param {object} target\n * @params {object} sources\n *\n * @returns {object}\n */\nexport function mergeDeepReactive(component, target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (typeof target[key] === 'undefined') {\n          component.$set(target, key, {});\n        }\n        mergeDeepReactive(component, target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        component.$set(target, key, source[key]);\n      } else if (typeof source[key] === 'function') {\n        if (source[key].toString().indexOf('[native code]') === -1) {\n          target[key] = source[key];\n        }\n      } else {\n        component.$set(target, key, source[key]);\n      }\n    }\n  }\n  return mergeDeepReactive(component, target, ...sources);\n}\n/**\n * Check if objects or arrays are equal by comparing nested values\n *\n * @param {object|array} left\n * @param {object|array} right\n *\n * @returns {boolean}\n */\nexport function notEqualDeep(left, right, cache = [], path = '') {\n  if (typeof right !== typeof left) {\n    return { left, right, what: path + '.typeof' };\n  } else if (Array.isArray(left) && !Array.isArray(right)) {\n    return { left, right, what: path + '.isArray' };\n  } else if (Array.isArray(right) && !Array.isArray(left)) {\n    return { left, right, what: path + '.isArray' };\n  } else if (Array.isArray(left) && Array.isArray(right)) {\n    if (left.length !== right.length) {\n      return { left, right, what: path + '.length' };\n    }\n    let what;\n    for (let index = 0, len = left.length; index < len; index++) {\n      if ((what = notEqualDeep(left[index], right[index], cache, path + '.' + index))) {\n        return what;\n      }\n    }\n  } else if (isObject(left) && !isObject(right)) {\n    return { left, right, what: path + '.isObject' };\n  } else if (isObject(right) && !isObject(left)) {\n    return { left, right, what: path + '.isObject' };\n  } else if (isObject(left) && isObject(right)) {\n    for (let key in left) {\n      if (!left.hasOwnProperty(key) || !left.propertyIsEnumerable(key)) {\n        continue;\n      }\n      if (!right.hasOwnProperty(key)) {\n        return { left, right, what: path + '.' + key };\n      }\n      let what;\n      if ((what = notEqualDeep(left[key], right[key], cache, path + '.' + key))) {\n        return what;\n      }\n    }\n  } else if (left !== right) {\n    return { left, right, what: path + '. !==' };\n  }\n  return false;\n}\n\n/**\n * GanttElastic\n * Main vue component\n */\nconst GanttElastic = {\n  name: 'GanttElastic',\n  components: {\n    MainView\n  },\n  props: ['tasks', 'options', 'dynamicStyle'],\n  provide() {\n    const provider = {};\n    const self = this;\n    Object.defineProperty(provider, 'root', {\n      enumerable: true,\n      get: () => self\n    });\n    return provider;\n  },\n  data() {\n    return {\n      state: {\n        tasks: [],\n        options: {\n          scrollBarHeight: 0,\n          allVisibleTasksHeight: 0,\n          outerHeight: 0,\n          scroll: {\n            left: 0,\n            top: 0\n          }\n        },\n        dynamicStyle: {},\n        refs: {},\n        tasksById: {},\n        taskTree: {},\n        ctx,\n        emitTasksChanges: true, // some operations may pause emitting changes to parent component\n        emitOptionsChanges: true, // some operations may pause emitting changes to parent component\n        resizeObserver: null,\n        unwatchTasks: null,\n        unwatchOptions: null,\n        unwatchStyle: null,\n        unwatchOutputTasks: null,\n        unwatchOutputOptions: null,\n        unwatchOutputStyle: null\n      }\n    };\n  },\n  methods: {\n    mergeDeep,\n    mergeDeepReactive,\n\n    /**\n     * Calculate height of scrollbar in current browser\n     *\n     * @returns {number}\n     */\n    getScrollBarHeight() {\n      const outer = document.createElement('div');\n      outer.style.visibility = 'hidden';\n      outer.style.height = '100px';\n      outer.style.msOverflowStyle = 'scrollbar';\n      document.body.appendChild(outer);\n      var noScroll = outer.offsetHeight;\n      outer.style.overflow = 'scroll';\n      var inner = document.createElement('div');\n      inner.style.height = '100%';\n      outer.appendChild(inner);\n      var withScroll = inner.offsetHeight;\n      outer.parentNode.removeChild(outer);\n      const height = noScroll - withScroll;\n      this.style['chart-scroll-container--vertical']['margin-left'] = `-${height}px`;\n      return (this.state.options.scrollBarHeight = height);\n    },\n\n    /**\n     * Fill out empty task properties and make it reactive\n     *\n     * @param {array} tasks\n     */\n    fillTasks(tasks) {\n      for (let task of tasks) {\n        if (typeof task.x === 'undefined') {\n          task.x = 0;\n        }\n        if (typeof task.y === 'undefined') {\n          task.y = 0;\n        }\n        if (typeof task.width === 'undefined') {\n          task.width = 0;\n        }\n        if (typeof task.height === 'undefined') {\n          task.height = 0;\n        }\n        if (typeof task.mouseOver === 'undefined') {\n          task.mouseOver = false;\n        }\n        if (typeof task.collapsed === 'undefined') {\n          task.collapsed = false;\n        }\n        if (typeof task.dependentOn === 'undefined') {\n          task.dependentOn = [];\n        }\n        if (typeof task.parentId === 'undefined') {\n          task.parentId = null;\n        }\n        if (typeof task.style === 'undefined') {\n          task.style = {};\n        }\n        if (typeof task.children === 'undefined') {\n          task.children = [];\n        }\n        if (typeof task.allChildren === 'undefined') {\n          task.allChildren = [];\n        }\n        if (typeof task.parents === 'undefined') {\n          task.parents = [];\n        }\n        if (typeof task.parent === 'undefined') {\n          task.parent = null;\n        }\n        if (typeof task.startTime === 'undefined') {\n          task.startTime = dayjs(task.start).valueOf();\n        }\n        if (typeof task.endTime === 'undefined' && task.hasOwnProperty('end')) {\n          task.endTime = dayjs(task.end).valueOf();\n        } else if (typeof task.endTime === 'undefined' && task.hasOwnProperty('duration')) {\n          task.endTime = task.startTime + task.duration;\n        }\n        if (typeof task.duration === 'undefined' && task.hasOwnProperty('endTime')) {\n          task.duration = task.endTime - task.startTime;\n        }\n      }\n      return tasks;\n    },\n\n    /**\n     * Map tasks\n     *\n     * @param {Array} tasks\n     * @param {Object} options\n     */\n    mapTasks(tasks, options) {\n      for (let [index, task] of tasks.entries()) {\n        tasks[index] = {\n          ...task,\n          id: task[options.taskMapping.id],\n          start: task[options.taskMapping.start],\n          label: task[options.taskMapping.label],\n          duration: task[options.taskMapping.duration],\n          progress: task[options.taskMapping.progress],\n          type: task[options.taskMapping.type],\n          style: task[options.taskMapping.style],\n          collapsed: task[options.taskMapping.collapsed]\n        };\n      }\n      return tasks;\n    },\n\n    /**\n     * Initialize component\n     */\n    initialize(itsUpdate = '') {\n      let options = mergeDeep({}, this.state.options, getOptions(this.options), this.options);\n      let tasks = this.mapTasks(this.tasks, options);\n      if (Object.keys(this.state.dynamicStyle).length === 0) {\n        this.initializeStyle();\n      }\n      dayjs.locale(options.locale, null, true);\n      dayjs.locale(options.locale.name);\n      if (typeof options.taskList === 'undefined') {\n        options.taskList = {};\n      }\n      options.taskList.columns = options.taskList.columns.map((column, index) => {\n        column.thresholdPercent = 100;\n        column.widthFromPercentage = 0;\n        column.finalWidth = 0;\n        if (typeof column.height === 'undefined') {\n          column.height = 0;\n        }\n        if (typeof column.style === 'undefined') {\n          column.style = {};\n        }\n        column._id = `${index}-${column.label}`;\n        return column;\n      });\n      this.state.options = options;\n      tasks = this.fillTasks(tasks);\n      this.state.tasksById = this.resetTaskTree(tasks);\n      this.state.taskTree = this.makeTaskTree(this.state.rootTask, tasks);\n      this.state.tasks = this.state.taskTree.allChildren.map(childId => this.getTask(childId));\n      this.calculateTaskListColumnsDimensions();\n      this.state.options.scrollBarHeight = this.getScrollBarHeight();\n      this.state.options.outerHeight = this.state.options.height + this.state.options.scrollBarHeight;\n      this.globalOnResize();\n    },\n\n    /**\n     * Initialize style\n     */\n    initializeStyle() {\n      this.state.dynamicStyle = mergeDeep({}, prepareStyle(this.dynamicStyle), this.dynamicStyle);\n    },\n\n    /**\n     * Get calendar rows outer height\n     *\n     * @returns {int}\n     */\n    getCalendarHeight() {\n      return this.state.options.calendar.height + this.state.options.calendar.strokeWidth;\n    },\n\n    /**\n     * Get maximal level of nested task children\n     *\n     * @returns {int}\n     */\n    getMaximalLevel() {\n      let maximalLevel = 0;\n      this.state.tasks.forEach(task => {\n        if (task.parents.length > maximalLevel) {\n          maximalLevel = task.parents.length;\n        }\n      });\n      return maximalLevel - 1;\n    },\n\n    /**\n     * Get maximal expander width - to calculate straight task list text\n     *\n     * @returns {int}\n     */\n    getMaximalExpanderWidth() {\n      return (\n        this.getMaximalLevel() * this.state.options.taskList.expander.padding +\n        this.state.options.taskList.expander.margin\n      );\n    },\n\n    /**\n     * Synchronize scrollTop property when row height is changed\n     */\n    syncScrollTop() {\n      if (\n        this.state.refs.taskListItems &&\n        this.state.refs.chartGraph.scrollTop !== this.state.refs.taskListItems.scrollTop\n      ) {\n        this.state.options.scroll.top = this.state.refs.taskListItems.scrollTop = this.state.refs.chartScrollContainerVertical.scrollTop = this.state.refs.chartGraph.scrollTop;\n      }\n    },\n\n    /**\n     * Calculate task list columns dimensions\n     */\n    calculateTaskListColumnsDimensions() {\n      let final = 0;\n      let percentage = 0;\n      for (let column of this.state.options.taskList.columns) {\n        if (column.expander) {\n          column.widthFromPercentage =\n            ((this.getMaximalExpanderWidth() + column.width) / 100) * this.state.options.taskList.percent;\n        } else {\n          column.widthFromPercentage = (column.width / 100) * this.state.options.taskList.percent;\n        }\n        percentage += column.widthFromPercentage;\n        column.finalWidth = (column.thresholdPercent * column.widthFromPercentage) / 100;\n        final += column.finalWidth;\n        column.height = this.getTaskHeight() - this.style['grid-line-horizontal']['stroke-width'];\n      }\n      this.state.options.taskList.widthFromPercentage = percentage;\n      this.state.options.taskList.finalWidth = final;\n    },\n\n    /**\n     * Reset task tree - which is used to create tree like structure inside task list\n     */\n    resetTaskTree(tasks) {\n      this.$set(this.state, 'rootTask', {\n        id: null,\n        label: 'root',\n        children: [],\n        allChildren: [],\n        parents: [],\n        parent: null,\n        __root: true\n      });\n      const tasksById = {};\n      for (let i = 0, len = tasks.length; i < len; i++) {\n        let current = tasks[i];\n        current.children = [];\n        current.allChildren = [];\n        current.parent = null;\n        current.parents = [];\n        tasksById[current.id] = current;\n      }\n      return tasksById;\n    },\n\n    /**\n     * Make task tree, after reset - look above\n     *\n     * @param {object} task\n     * @returns {object} tasks with children and parents\n     */\n    makeTaskTree(task, tasks) {\n      for (let i = 0, len = tasks.length; i < len; i++) {\n        let current = tasks[i];\n        if (current.parentId === task.id) {\n          if (task.parents.length) {\n            task.parents.forEach(parent => current.parents.push(parent));\n          }\n          if (!task.propertyIsEnumerable('__root')) {\n            current.parents.push(task.id);\n            current.parent = task.id;\n          } else {\n            current.parents = [];\n            current.parent = null;\n          }\n          current = this.makeTaskTree(current, tasks);\n          task.allChildren.push(current.id);\n          task.children.push(current.id);\n          current.allChildren.forEach(childId => task.allChildren.push(childId));\n        }\n      }\n      return task;\n    },\n\n    /**\n     * Get task by id\n     *\n     * @param {any} taskId\n     * @returns {object|null} task\n     */\n    getTask(taskId) {\n      if (typeof this.state.tasksById[taskId] !== 'undefined') {\n        return this.state.tasksById[taskId];\n      }\n      return null;\n    },\n\n    /**\n     * Get children tasks for specified taskId\n     *\n     * @param {any} taskId\n     * @returns {array} children\n     */\n    getChildren(taskId) {\n      return this.state.tasks.filter(task => task.parent === taskId);\n    },\n\n    /**\n     * Is task visible\n     *\n     * @param {Number|String|Task} task\n     */\n    isTaskVisible(task) {\n      if (typeof task === 'number' || typeof task === 'string') {\n        task = this.getTask(task);\n      }\n      for (let i = 0, len = task.parents.length; i < len; i++) {\n        if (this.getTask(task.parents[i]).collapsed) {\n          return false;\n        }\n      }\n      return true;\n    },\n\n    /**\n     * Get svg\n     *\n     * @returns {string} html svg image of gantt\n     */\n    getSVG() {\n      return this.state.options.mainView.outerHTML;\n    },\n\n    /**\n     * Get image\n     *\n     * @param {string} type image format\n     * @returns {Promise} when resolved returns base64 image string of gantt\n     */\n    getImage(type = 'image/png') {\n      return new Promise(resolve => {\n        const img = new Image();\n        img.onload = () => {\n          const canvas = document.createElement('canvas');\n          canvas.width = this.state.options.mainView.clientWidth;\n          canvas.height = this.state.options.rowsHeight;\n          canvas.getContext('2d').drawImage(img, 0, 0);\n          resolve(canvas.toDataURL(type));\n        };\n        img.src = 'data:image/svg+xml,' + encodeURIComponent(this.getSVG());\n      });\n    },\n\n    /**\n     * Get gantt total height\n     *\n     * @returns {number}\n     */\n    getHeight(visibleTasks, outer = false) {\n      let height =\n        visibleTasks.length * (this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2) +\n        this.state.options.calendar.height +\n        this.state.options.calendar.strokeWidth +\n        this.state.options.calendar.gap;\n      if (outer) {\n        height += this.state.options.scrollBarHeight;\n      }\n      return height;\n    },\n\n    /**\n     * Get one task height\n     *\n     * @returns {number}\n     */\n    getTaskHeight(withStroke = false) {\n      if (withStroke) {\n        return (\n          this.state.options.row.height +\n          this.state.options.chart.grid.horizontal.gap * 2 +\n          this.style['grid-line-horizontal']['stroke-width']\n        );\n      }\n      return this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2;\n    },\n\n    /**\n     * Get specified tasks height\n     *\n     * @returns {number}\n     */\n    getTasksHeight(visibleTasks) {\n      return visibleTasks.length * this.getTaskHeight();\n    },\n\n    /**\n     * Convert time (in milliseconds) to pixel offset inside chart\n     *\n     * @param {int} ms\n     * @returns {number}\n     */\n    timeToPixelOffsetX(ms) {\n      let x = ms - this.state.options.times.firstTime;\n      if (x) {\n        x = x / this.state.options.times.timePerPixel;\n      }\n      return x;\n    },\n\n    /**\n     * Convert pixel offset inside chart to corresponding time offset in milliseconds\n     *\n     * @param {number} pixelOffsetX\n     * @returns {int} milliseconds\n     */\n    pixelOffsetXToTime(pixelOffsetX) {\n      let offset = pixelOffsetX + this.style['grid-line-vertical']['stroke-width'] / 2;\n      return offset * this.state.options.times.timePerPixel + this.state.options.times.firstTime;\n    },\n\n    /**\n     * Determine if element is inside current view port\n     *\n     * @param {number} x - element placement\n     * @param {number} width - element width\n     * @param {int} buffer - or threshold, if element is outside viewport but offset from view port is below this value return true\n     * @returns {boolean}\n     */\n    isInsideViewPort(x, width, buffer = 5000) {\n      return (\n        (x + width + buffer >= this.state.options.scroll.chart.left &&\n          x - buffer <= this.state.options.scroll.chart.right) ||\n        (x - buffer <= this.state.options.scroll.chart.left &&\n          x + width + buffer >= this.state.options.scroll.chart.right)\n      );\n    },\n\n    /**\n     * Chart scroll event handler\n     *\n     * @param {event} ev\n     */\n    onScrollChart(ev) {\n      this._onScrollChart(\n        this.state.refs.chartScrollContainerHorizontal.scrollLeft,\n        this.state.refs.chartScrollContainerVertical.scrollTop\n      );\n    },\n\n    /**\n     * After same as above but with different arguments - normalized\n     *\n     * @param {number} left\n     * @param {number} top\n     */\n    _onScrollChart(left, top) {\n      if (this.state.options.scroll.chart.left === left && this.state.options.scroll.chart.top === top) {\n        return;\n      }\n      const chartContainerWidth = this.state.refs.chartContainer.clientWidth;\n      this.state.options.scroll.chart.left = left;\n      this.state.options.scroll.chart.right = left + chartContainerWidth;\n      this.state.options.scroll.chart.percent = (left / this.state.options.times.totalViewDurationPx) * 100;\n      this.state.options.scroll.chart.top = top;\n      this.state.options.scroll.chart.time = this.pixelOffsetXToTime(left);\n      this.state.options.scroll.chart.timeCenter = this.pixelOffsetXToTime(left + chartContainerWidth / 2);\n      this.state.options.scroll.chart.dateTime.left = dayjs(this.state.options.scroll.chart.time).valueOf();\n      this.state.options.scroll.chart.dateTime.right = dayjs(\n        this.pixelOffsetXToTime(left + this.state.refs.chart.clientWidth)\n      ).valueOf();\n      this.scrollTo(left, top);\n    },\n\n    /**\n     * Scroll current chart to specified time (in milliseconds)\n     *\n     * @param {int} time\n     */\n    scrollToTime(time) {\n      let pos = this.timeToPixelOffsetX(time);\n      const chartContainerWidth = this.state.refs.chartContainer.clientWidth;\n      pos = pos - chartContainerWidth / 2;\n      if (pos > this.state.options.width) {\n        pos = this.state.options.width - chartContainerWidth;\n      }\n      this.scrollTo(pos);\n    },\n\n    /**\n     * Scroll chart or task list to specified pixel values\n     *\n     * @param {number|null} left\n     * @param {number|null} top\n     */\n    scrollTo(left = null, top = null) {\n      if (left !== null) {\n        this.state.refs.chartCalendarContainer.scrollLeft = left;\n        this.state.refs.chartGraphContainer.scrollLeft = left;\n        this.state.refs.chartScrollContainerHorizontal.scrollLeft = left;\n        this.state.options.scroll.left = left;\n      }\n      if (top !== null) {\n        this.state.refs.chartScrollContainerVertical.scrollTop = top;\n        this.state.refs.chartGraph.scrollTop = top;\n        this.state.refs.taskListItems.scrollTop = top;\n        this.state.options.scroll.top = top;\n        this.syncScrollTop();\n      }\n    },\n\n    /**\n     * After some actions like time zoom change we need to recompensate scroll position\n     * so as a result everything will be in same place\n     */\n    fixScrollPos() {\n      this.scrollToTime(this.state.options.scroll.chart.timeCenter);\n    },\n\n    /**\n     * Mouse wheel event handler\n     */\n    onWheelChart(ev) {\n      if (!ev.shiftKey && ev.deltaX === 0) {\n        let top = this.state.options.scroll.top + ev.deltaY;\n        const chartClientHeight = this.state.options.rowsHeight;\n        const scrollHeight = this.state.refs.chartGraph.scrollHeight - chartClientHeight;\n        if (top < 0) {\n          top = 0;\n        } else if (top > scrollHeight) {\n          top = scrollHeight;\n        }\n        this.scrollTo(null, top);\n      } else if (ev.shiftKey && ev.deltaX === 0) {\n        let left = this.state.options.scroll.left + ev.deltaY;\n        const chartClientWidth = this.state.refs.chartScrollContainerHorizontal.clientWidth;\n        const scrollWidth = this.state.refs.chartScrollContainerHorizontal.scrollWidth - chartClientWidth;\n        if (left < 0) {\n          left = 0;\n        } else if (left > scrollWidth) {\n          left = scrollWidth;\n        }\n        this.scrollTo(left);\n      } else {\n        let left = this.state.options.scroll.left + ev.deltaX;\n        const chartClientWidth = this.state.refs.chartScrollContainerHorizontal.clientWidth;\n        const scrollWidth = this.state.refs.chartScrollContainerHorizontal.scrollWidth - chartClientWidth;\n        if (left < 0) {\n          left = 0;\n        } else if (left > scrollWidth) {\n          left = scrollWidth;\n        }\n        this.scrollTo(left);\n      }\n    },\n\n    /**\n     * Time zoom change event handler\n     */\n    onTimeZoomChange(timeZoom) {\n      this.state.options.times.timeZoom = timeZoom;\n      this.recalculateTimes();\n      this.calculateSteps();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Row height change event handler\n     */\n    onRowHeightChange(height) {\n      this.state.options.row.height = height;\n      this.calculateTaskListColumnsDimensions();\n      this.syncScrollTop();\n    },\n\n    /**\n     * Scope change event handler\n     */\n    onScopeChange(value) {\n      this.state.options.scope.before = value;\n      this.state.options.scope.after = value;\n      this.initTimes();\n      this.calculateSteps();\n      this.computeCalendarWidths();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Task list width change event handler\n     */\n    onTaskListWidthChange(value) {\n      this.state.options.taskList.percent = value;\n      this.calculateTaskListColumnsDimensions();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Task list column width change event handler\n     */\n    onTaskListColumnWidthChange() {\n      this.calculateTaskListColumnsDimensions();\n      this.fixScrollPos();\n    },\n\n    /**\n     * Listen to specified event names\n     */\n    initializeEvents() {\n      this.$on('chart-scroll-horizontal', this.onScrollChart);\n      this.$on('chart-scroll-vertical', this.onScrollChart);\n      this.$on('chart-wheel', this.onWheelChart);\n      this.$on('times-timeZoom-change', this.onTimeZoomChange);\n      this.$on('row-height-change', this.onRowHeightChange);\n      this.$on('scope-change', this.onScopeChange);\n      this.$on('taskList-width-change', this.onTaskListWidthChange);\n      this.$on('taskList-column-width-change', this.onTaskListColumnWidthChange);\n    },\n\n    /**\n     * When some action was performed (scale change for example) - recalculate time variables\n     */\n    recalculateTimes() {\n      let max = this.state.options.times.timeScale * 60;\n      let min = this.state.options.times.timeScale;\n      let steps = max / min;\n      let percent = this.state.options.times.timeZoom / 100;\n      this.state.options.times.timePerPixel =\n        this.state.options.times.timeScale * steps * percent + Math.pow(2, this.state.options.times.timeZoom);\n      this.state.options.times.totalViewDurationMs = dayjs(this.state.options.times.lastTime).diff(\n        this.state.options.times.firstTime,\n        'milliseconds'\n      );\n      this.state.options.times.totalViewDurationPx =\n        this.state.options.times.totalViewDurationMs / this.state.options.times.timePerPixel;\n      this.state.options.width =\n        this.state.options.times.totalViewDurationPx + this.style['grid-line-vertical']['stroke-width'];\n    },\n\n    /**\n     * Initialize time variables\n     */\n    initTimes() {\n      this.state.options.times.firstTime = dayjs(this.state.options.times.firstTaskTime)\n        .locale(this.state.options.locale.name)\n        .startOf('day')\n        .subtract(this.state.options.scope.before, 'days')\n        .startOf('day')\n        .valueOf();\n      this.state.options.times.lastTime = dayjs(this.state.options.times.lastTaskTime)\n        .locale(this.state.options.locale.name)\n        .endOf('day')\n        .add(this.state.options.scope.after, 'days')\n        .endOf('day')\n        .valueOf();\n      this.recalculateTimes();\n    },\n\n    /**\n     * Calculate steps\n     * Steps are days by default\n     * Each step contain information about time offset and pixel offset of this time inside gantt chart\n     */\n    calculateSteps() {\n      const steps = [];\n      const lastMs = dayjs(this.state.options.times.lastTime).valueOf();\n      const currentDate = dayjs(this.state.options.times.firstTime);\n      steps.push({\n        time: currentDate.valueOf(),\n        offset: {\n          ms: 0,\n          px: 0\n        }\n      });\n      for (\n        let currentDate = dayjs(this.state.options.times.firstTime)\n          .add(1, this.state.options.times.stepDuration)\n          .startOf('day');\n        currentDate.valueOf() <= lastMs;\n        currentDate = currentDate.add(1, this.state.options.times.stepDuration).startOf('day')\n      ) {\n        const offsetMs = currentDate.diff(this.state.options.times.firstTime, 'milliseconds');\n        const offsetPx = offsetMs / this.state.options.times.timePerPixel;\n        const step = {\n          time: currentDate.valueOf(),\n          offset: {\n            ms: offsetMs,\n            px: offsetPx\n          }\n        };\n        const previousStep = steps[steps.length - 1];\n        previousStep.width = {\n          ms: offsetMs - previousStep.offset.ms,\n          px: offsetPx - previousStep.offset.px\n        };\n        steps.push(step);\n      }\n      const lastStep = steps[steps.length - 1];\n      lastStep.width = {\n        ms: this.state.options.times.totalViewDurationMs - lastStep.offset.ms,\n        px: this.state.options.times.totalViewDurationPx - lastStep.offset.px\n      };\n      this.state.options.times.steps = steps;\n    },\n\n    /**\n     * Calculate calendar widths - when scale was changed for example\n     */\n    computeCalendarWidths() {\n      this.computeDayWidths();\n      this.computeHourWidths();\n      this.computeMonthWidths();\n    },\n\n    /**\n     * Compute width of calendar hours column widths basing on text widths\n     */\n    computeHourWidths() {\n      const style = { ...this.style['calendar-row-text'], ...this.style['calendar-row-text--hour'] };\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      const localeName = this.state.options.locale.name;\n      let currentDate = dayjs('2018-01-01T00:00:00').locale(localeName); // any date will be good for hours\n      let maxWidths = this.state.options.calendar.hour.maxWidths;\n      if (maxWidths.length) {\n        return;\n      }\n      for (let formatName in this.state.options.calendar.hour.format) {\n        maxWidths[formatName] = 0;\n      }\n      for (let hour = 0; hour < 24; hour++) {\n        let widths = { hour };\n        for (let formatName in this.state.options.calendar.hour.format) {\n          const hourFormatted = this.state.options.calendar.hour.format[formatName](currentDate);\n          this.state.options.calendar.hour.formatted[formatName].push(hourFormatted);\n          widths[formatName] = this.state.ctx.measureText(hourFormatted).width;\n        }\n        this.state.options.calendar.hour.widths.push(widths);\n        for (let formatName in this.state.options.calendar.hour.format) {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        }\n        currentDate = currentDate.add(1, 'hour');\n      }\n    },\n\n    /**\n     * Compute calendar days column widths basing on text widths\n     */\n    computeDayWidths() {\n      const style = { ...this.style['calendar-row-text'], ...this.style['calendar-row-text--day'] };\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      const localeName = this.state.options.locale.name;\n      let currentDate = dayjs(this.state.options.times.steps[0].time).locale(localeName);\n      let maxWidths = this.state.options.calendar.day.maxWidths;\n      this.state.options.calendar.day.widths = [];\n      Object.keys(this.state.options.calendar.day.format).forEach(formatName => {\n        maxWidths[formatName] = 0;\n      });\n      for (let day = 0, daysLen = this.state.options.times.steps.length; day < daysLen; day++) {\n        const widths = {\n          day\n        };\n        Object.keys(this.state.options.calendar.day.format).forEach(formatName => {\n          widths[formatName] = this.state.ctx.measureText(\n            this.state.options.calendar.day.format[formatName](currentDate)\n          ).width;\n        });\n        this.state.options.calendar.day.widths.push(widths);\n        Object.keys(this.state.options.calendar.day.format).forEach(formatName => {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        });\n        currentDate = currentDate.add(1, 'day');\n      }\n    },\n\n    /**\n     * Months count\n     *\n     * @description Returns number of different months in specified time range\n     *\n     * @param {number} fromTime - date in ms\n     * @param {number} toTime - date in ms\n     *\n     * @returns {number} different months count\n     */\n    monthsCount(fromTime, toTime) {\n      if (fromTime > toTime) {\n        return 0;\n      }\n      let currentMonth = dayjs(fromTime);\n      let previousMonth = currentMonth.clone();\n      let monthsCount = 1;\n      while (currentMonth.valueOf() <= toTime) {\n        currentMonth = currentMonth.add(1, 'day');\n        if (previousMonth.month() !== currentMonth.month()) {\n          monthsCount++;\n        }\n        previousMonth = currentMonth.clone();\n      }\n      return monthsCount;\n    },\n\n    /**\n     * Compute month calendar columns widths basing on text widths\n     */\n    computeMonthWidths() {\n      const style = { ...this.style['calendar-row-text'], ...this.style['calendar-row-text--month'] };\n      this.state.ctx.font = style['font-size'] + ' ' + style['font-family'];\n      let maxWidths = this.state.options.calendar.month.maxWidths;\n      this.state.options.calendar.month.widths = [];\n      Object.keys(this.state.options.calendar.month.format).forEach(formatName => {\n        maxWidths[formatName] = 0;\n      });\n      const localeName = this.state.options.locale.name;\n      let currentDate = dayjs(this.state.options.times.firstTime).locale(localeName);\n      const monthsCount = this.monthsCount(this.state.options.times.firstTime, this.state.options.times.lastTime);\n      for (let month = 0; month < monthsCount; month++) {\n        const widths = {\n          month\n        };\n        Object.keys(this.state.options.calendar.month.format).forEach(formatName => {\n          widths[formatName] = this.state.ctx.measureText(\n            this.state.options.calendar.month.format[formatName](currentDate)\n          ).width;\n        });\n        this.state.options.calendar.month.widths.push(widths);\n        Object.keys(this.state.options.calendar.month.format).forEach(formatName => {\n          if (widths[formatName] > maxWidths[formatName]) {\n            maxWidths[formatName] = widths[formatName];\n          }\n        });\n        currentDate = currentDate.add(1, 'month');\n      }\n    },\n\n    /**\n     * Prepare time and date variables for gantt\n     */\n    prepareDates() {\n      let firstTaskTime = Number.MAX_SAFE_INTEGER;\n      let lastTaskTime = 0;\n      for (let index = 0, len = this.state.tasks.length; index < len; index++) {\n        let task = this.state.tasks[index];\n        if (task.startTime < firstTaskTime) {\n          firstTaskTime = task.startTime;\n        }\n        if (task.startTime + task.duration > lastTaskTime) {\n          lastTaskTime = task.startTime + task.duration;\n        }\n      }\n      this.state.options.times.firstTaskTime = firstTaskTime;\n      this.state.options.times.lastTaskTime = lastTaskTime;\n      this.state.options.times.firstTime = dayjs(firstTaskTime)\n        .locale(this.state.options.locale.name)\n        .startOf('day')\n        .subtract(this.state.options.scope.before, 'days')\n        .startOf('day')\n        .valueOf();\n      this.state.options.times.lastTime = dayjs(lastTaskTime)\n        .locale(this.state.options.locale.name)\n        .endOf('day')\n        .add(this.state.options.scope.after, 'days')\n        .endOf('day')\n        .valueOf();\n    },\n\n    /**\n     * Setup and calculate everything\n     */\n    setup(itsUpdate = '') {\n      this.initialize(itsUpdate);\n      this.prepareDates();\n      this.initTimes();\n      this.calculateSteps();\n      this.computeCalendarWidths();\n      this.state.options.taskList.width = this.state.options.taskList.columns.reduce(\n        (prev, current) => {\n          return { width: prev.width + current.width };\n        },\n        { width: 0 }\n      ).width;\n    },\n\n    /**\n     * Global resize event (from window.addEventListener)\n     */\n    globalOnResize() {\n      if (typeof this.$el === 'undefined' || !this.$el) {\n        return;\n      }\n      this.state.options.clientWidth = this.$el.clientWidth;\n      if (\n        this.state.options.taskList.widthFromPercentage >\n        (this.state.options.clientWidth / 100) * this.state.options.taskList.widthThreshold\n      ) {\n        const diff =\n          this.state.options.taskList.widthFromPercentage -\n          (this.state.options.clientWidth / 100) * this.state.options.taskList.widthThreshold;\n        let diffPercent = 100 - (diff / this.state.options.taskList.widthFromPercentage) * 100;\n        if (diffPercent < 0) {\n          diffPercent = 0;\n        }\n        this.state.options.taskList.columns.forEach(column => {\n          column.thresholdPercent = diffPercent;\n        });\n      } else {\n        this.state.options.taskList.columns.forEach(column => {\n          column.thresholdPercent = 100;\n        });\n      }\n      this.calculateTaskListColumnsDimensions();\n      this.$emit('calendar-recalculate');\n      this.syncScrollTop();\n    }\n  },\n\n  computed: {\n    /**\n     * Get visible tasks\n     * Very important method which will bring us only those tasks that are visible inside gantt chart\n     * For example when task is collapsed - children of this task are not visible - we should not render them\n     */\n    visibleTasks() {\n      const visibleTasks = this.state.tasks.filter(task => this.isTaskVisible(task));\n      const maxRows = visibleTasks.slice(0, this.state.options.maxRows);\n      this.state.options.rowsHeight = this.getTasksHeight(maxRows);\n      let heightCompensation = 0;\n      if (this.state.options.maxHeight && this.state.options.rowsHeight > this.state.options.maxHeight) {\n        heightCompensation = this.state.options.rowsHeight - this.state.options.maxHeight;\n        this.state.options.rowsHeight = this.state.options.maxHeight;\n      }\n      this.state.options.height = this.getHeight(maxRows) - heightCompensation;\n      this.state.options.allVisibleTasksHeight = this.getTasksHeight(visibleTasks);\n      this.state.options.outerHeight = this.getHeight(maxRows, true) - heightCompensation;\n      let len = visibleTasks.length;\n      for (let index = 0; index < len; index++) {\n        let task = visibleTasks[index];\n        task.width =\n          task.duration / this.state.options.times.timePerPixel - this.style['grid-line-vertical']['stroke-width'];\n        if (task.width < 0) {\n          task.width = 0;\n        }\n        task.height = this.state.options.row.height;\n        task.x = this.timeToPixelOffsetX(task.startTime);\n        task.y =\n          (this.state.options.row.height + this.state.options.chart.grid.horizontal.gap * 2) * index +\n          this.state.options.chart.grid.horizontal.gap;\n      }\n      return visibleTasks;\n    },\n\n    /**\n     * Style shortcut\n     */\n    style() {\n      return this.state.dynamicStyle;\n    },\n\n    /**\n     * Get columns and compute dimensions on the fly\n     */\n    getTaskListColumns() {\n      this.calculateTaskListColumnsDimensions();\n      return this.state.options.taskList.columns;\n    },\n\n    /**\n     * Tasks used for communicate with parent component\n     */\n    outputTasks() {\n      return this.state.tasks;\n    },\n\n    /**\n     * Options used to communicate with parent component\n     */\n    outputOptions() {\n      return this.state.options;\n    }\n  },\n\n  /**\n   * Watch tasks after gantt instance is created and react when we have new kids on the block\n   */\n  created() {\n    this.initializeEvents();\n    this.setup();\n    this.state.unwatchTasks = this.$watch(\n      'tasks',\n      tasks => {\n        const notEqual = notEqualDeep(tasks, this.outputTasks);\n        if (notEqual) {\n          this.setup('tasks');\n        }\n      },\n      { deep: true }\n    );\n    this.state.unwatchOptions = this.$watch(\n      'options',\n      opts => {\n        const notEqual = notEqualDeep(opts, this.outputOptions);\n        if (notEqual) {\n          this.setup('options');\n        }\n      },\n      { deep: true }\n    );\n    this.state.unwatchStyle = this.$watch(\n      'dynamicStyle',\n      style => {\n        const notEqual = notEqualDeep(style, this.dynamicStyle);\n        if (notEqual) {\n          this.initializeStyle();\n        }\n      },\n      { deep: true, immediate: true }\n    );\n\n    this.state.unwatchOutputTasks = this.$watch(\n      'outputTasks',\n      tasks => {\n        this.$emit('tasks-changed', tasks.map(task => task));\n      },\n      { deep: true }\n    );\n    this.state.unwatchOutputOptions = this.$watch(\n      'outputOptions',\n      options => {\n        this.$emit('options-changed', mergeDeep({}, options));\n      },\n      { deep: true }\n    );\n    this.state.unwatchOutputStyle = this.$watch(\n      'style',\n      style => {\n        this.$emit('dynamic-style-changed', mergeDeep({}, style));\n      },\n      { deep: true }\n    );\n\n    this.$root.$emit('gantt-elastic-created', this);\n    this.$emit('created', this);\n  },\n\n  /**\n   * Emit before-mount event\n   */\n  beforeMount() {\n    this.$emit('before-mount', this);\n  },\n\n  /**\n   * Emit ready/mounted events and deliver this gantt instance to outside world when needed\n   */\n  mounted() {\n    this.state.options.clientWidth = this.$el.clientWidth;\n    this.state.resizeObserver = new ResizeObserver((entries, observer) => {\n      this.globalOnResize();\n    });\n    this.state.resizeObserver.observe(this.$el.parentNode);\n    this.globalOnResize();\n    this.$emit('ready', this);\n    this.$root.$emit('gantt-elastic-mounted', this);\n    this.$emit('mounted', this);\n    this.$root.$emit('gantt-elastic-ready', this);\n  },\n\n  /**\n   * Emit event when data was changed and before update (you can cleanup dom events here for example)\n   */\n  beforeUpdate() {\n    this.$emit('before-update');\n  },\n\n  /**\n   * Emit event when gantt-elastic view was updated\n   */\n  updated() {\n    this.$nextTick(() => {\n      this.$emit('updated');\n    });\n  },\n\n  /**\n   * Before destroy event - clean up\n   */\n  beforeDestroy() {\n    this.state.resizeObserver.unobserve(this.$el.parentNode);\n    this.state.unwatchTasks();\n    this.state.unwatchOptions();\n    this.state.unwatchStyle();\n    this.state.unwatchOutputTasks();\n    this.state.unwatchOutputOptions();\n    this.state.unwatchOutputStyle();\n    this.$emit('before-destroy');\n  },\n\n  /**\n   * Emit event after gantt-elastic was destroyed\n   */\n  destroyed() {\n    this.$emit('destroyed');\n  }\n};\nexport default GanttElastic;\n</script>\n\n<style>\n[class^='gantt-elastic'],\n[class*=' gantt-elastic'] {\n  box-sizing: border-box;\n}\n.gantt-elastic__main-view svg {\n  display: block;\n}\n.gantt-elastic__grid-horizontal-line,\n.gantt-elastic__grid-vertical-line {\n  stroke: #a0a0a0;\n  stroke-width: 1;\n}\nforeignObject > * {\n  margin: 0px;\n}\n.gantt-elastic .p-2 {\n  padding: 10rem;\n}\n.gantt-elastic__main-view-main-container,\n.gantt-elastic__main-view-container {\n  overflow: hidden;\n  max-width: 100%;\n}\n.gantt-elastic__task-list-header-column:last-of-type {\n  border-right: 1px solid #00000050;\n}\n.gantt-elastic__task-list-item:last-of-type {\n  border-bottom: 1px solid #00000050;\n}\n.gantt-elastic__task-list-item-value-wrapper:hover {\n  overflow: visible !important;\n}\n.gantt-elastic__task-list-item-value-wrapper:hover > .gantt-elastic__task-list-item-value-container {\n  position: relative;\n  overflow: visible !important;\n}\n.gantt-elastic__task-list-item-value-wrapper:hover > .gantt-elastic__task-list-item-value {\n  position: absolute;\n}\n</style>\n"],"sourceRoot":"node_modules/gantt-elastic/src"}]}