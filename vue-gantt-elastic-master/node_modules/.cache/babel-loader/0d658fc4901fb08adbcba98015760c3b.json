{"remainingRequest":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/babel-loader/lib/index.js!/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/gantt-elastic/src/components/Chart/DependencyLines.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/gantt-elastic/src/components/Chart/DependencyLines.vue","mtime":1664650536313},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/cache-loader/dist/cjs.js","mtime":1664650533042},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/babel-loader/lib/index.js","mtime":1664650533420},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/cache-loader/dist/cjs.js","mtime":1664650533042},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/vue-loader/lib/index.js","mtime":1664650526464}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nexport default {\n  name: 'DependencyLines',\n  inject: ['root'],\n  props: ['tasks'],\n  data: function data() {\n    return {};\n  },\n  methods: {\n    /**\n     * Get path points\n     *\n     * @param {any} fromTaskId\n     * @param {any} toTaskId\n     * @returns {string}\n     */\n    getPoints: function getPoints(fromTaskId, toTaskId) {\n      var fromTask = this.root.getTask(fromTaskId);\n      var toTask = this.root.getTask(toTaskId);\n\n      if (fromTask === null || toTask === null || !this.root.isTaskVisible(toTask) || !this.root.isTaskVisible(fromTask)) {\n        return null;\n      }\n\n      var startX = fromTask.x + fromTask.width;\n      var startY = fromTask.y + fromTask.height / 2;\n      var stopX = toTask.x;\n      var stopY = toTask.y + toTask.height / 2;\n      var distanceX = stopX - startX;\n      var distanceY;\n      var yMultiplier = 1;\n\n      if (stopY >= startY) {\n        distanceY = stopY - startY;\n      } else {\n        distanceY = startY - stopY;\n        yMultiplier = -1;\n      }\n\n      var offset = 10;\n      var roundness = 4;\n      var isBefore = distanceX <= offset + roundness;\n      var points = \"M \".concat(startX, \" \").concat(startY, \"\\n          L \").concat(startX + offset, \",\").concat(startY, \" \");\n\n      if (isBefore) {\n        points += \"Q \".concat(startX + offset + roundness, \",\").concat(startY, \" \").concat(startX + offset + roundness, \",\").concat(startY + roundness * yMultiplier, \"\\n            L \").concat(startX + offset + roundness, \",\").concat(startY + distanceY * yMultiplier / 2 - roundness * yMultiplier, \"\\n            Q \").concat(startX + offset + roundness, \",\").concat(startY + distanceY * yMultiplier / 2, \" \").concat(startX + offset, \",\").concat(startY + distanceY * yMultiplier / 2, \"\\n            L \").concat(startX - offset + distanceX, \",\").concat(startY + distanceY * yMultiplier / 2, \"\\n            Q \").concat(startX - offset + distanceX - roundness, \",\").concat(startY + distanceY * yMultiplier / 2, \" \").concat(startX - offset + distanceX - roundness, \",\").concat(startY + distanceY * yMultiplier / 2 + roundness * yMultiplier, \"\\n            L \").concat(startX - offset + distanceX - roundness, \",\").concat(stopY - roundness * yMultiplier, \"\\n            Q \").concat(startX - offset + distanceX - roundness, \",\").concat(stopY, \" \").concat(startX - offset + distanceX, \",\").concat(stopY, \"\\n            L \").concat(stopX, \",\").concat(stopY);\n      } else {\n        points += \"L \".concat(startX + distanceX / 2 - roundness, \",\").concat(startY, \"\\n            Q \").concat(startX + distanceX / 2, \",\").concat(startY, \" \").concat(startX + distanceX / 2, \",\").concat(startY + roundness * yMultiplier, \"\\n            L \").concat(startX + distanceX / 2, \",\").concat(stopY - roundness * yMultiplier, \"\\n            Q \").concat(startX + distanceX / 2, \",\").concat(stopY, \" \").concat(startX + distanceX / 2 + roundness, \",\").concat(stopY, \"\\n            L \").concat(stopX, \",\").concat(stopY);\n      }\n\n      return points;\n    }\n  },\n  computed: {\n    /**\n     * Get tasks which are dependent on other tasks\n     *\n     * @returns {array}\n     */\n    dependencyTasks: function dependencyTasks() {\n      var _this = this;\n\n      return this.tasks.filter(function (task) {\n        return typeof task.dependentOn !== 'undefined';\n      }).map(function (task) {\n        task.dependencyLines = task.dependentOn.map(function (id) {\n          return {\n            points: _this.getPoints(id, task.id)\n          };\n        });\n        return task;\n      }).filter(function (task) {\n        return task.dependencyLines.points !== null;\n      });\n    }\n  }\n};",{"version":3,"sources":["DependencyLines.vue"],"names":[],"mappings":"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","sourcesContent":["<!--\n/**\n * @fileoverview DependencyLines component\n * @license MIT\n * @author Rafal Pospiech <neuronet.io@gmail.com>\n * @package GanttElastic\n */\n-->\n<template>\n  <svg\n    x=\"0\"\n    y=\"0\"\n    width=\"100%\"\n    height=\"100%\"\n    class=\"gantt-elastic__chart-dependency-lines-container\"\n    :style=\"{ ...root.style['chart-dependency-lines-container'] }\"\n  >\n    <g v-for=\"task in dependencyTasks\" :key=\"task.id\" :task=\"task\">\n      <path\n        class=\"gantt-elastic__chart-dependency-lines-path\"\n        :style=\"{ ...root.style['chart-dependency-lines-path'], ...task.style['chart-dependency-lines-path'] }\"\n        v-for=\"dependencyLine in task.dependencyLines\"\n        :key=\"dependencyLine.id\"\n        :task=\"task\"\n        :d=\"dependencyLine.points\"\n      ></path>\n    </g>\n  </svg>\n</template>\n\n<script>\nexport default {\n  name: 'DependencyLines',\n  inject: ['root'],\n  props: ['tasks'],\n  data() {\n    return {};\n  },\n  methods: {\n    /**\n     * Get path points\n     *\n     * @param {any} fromTaskId\n     * @param {any} toTaskId\n     * @returns {string}\n     */\n    getPoints(fromTaskId, toTaskId) {\n      const fromTask = this.root.getTask(fromTaskId);\n      const toTask = this.root.getTask(toTaskId);\n      if (\n        fromTask === null ||\n        toTask === null ||\n        !this.root.isTaskVisible(toTask) ||\n        !this.root.isTaskVisible(fromTask)\n      ) {\n        return null;\n      }\n      const startX = fromTask.x + fromTask.width;\n      const startY = fromTask.y + fromTask.height / 2;\n      const stopX = toTask.x;\n      const stopY = toTask.y + toTask.height / 2;\n      const distanceX = stopX - startX;\n      let distanceY;\n      let yMultiplier = 1;\n      if (stopY >= startY) {\n        distanceY = stopY - startY;\n      } else {\n        distanceY = startY - stopY;\n        yMultiplier = -1;\n      }\n      const offset = 10;\n      const roundness = 4;\n      const isBefore = distanceX <= offset + roundness;\n      let points = `M ${startX} ${startY}\n          L ${startX + offset},${startY} `;\n      if (isBefore) {\n        points += `Q ${startX + offset + roundness},${startY} ${startX + offset + roundness},${startY +\n          roundness * yMultiplier}\n            L ${startX + offset + roundness},${startY + (distanceY * yMultiplier) / 2 - roundness * yMultiplier}\n            Q ${startX + offset + roundness},${startY + (distanceY * yMultiplier) / 2} ${startX + offset},${startY +\n          (distanceY * yMultiplier) / 2}\n            L ${startX - offset + distanceX},${startY + (distanceY * yMultiplier) / 2}\n            Q ${startX - offset + distanceX - roundness},${startY + (distanceY * yMultiplier) / 2} ${startX -\n          offset +\n          distanceX -\n          roundness},${startY + (distanceY * yMultiplier) / 2 + roundness * yMultiplier}\n            L ${startX - offset + distanceX - roundness},${stopY - roundness * yMultiplier}\n            Q ${startX - offset + distanceX - roundness},${stopY} ${startX - offset + distanceX},${stopY}\n            L ${stopX},${stopY}`;\n      } else {\n        points += `L ${startX + distanceX / 2 - roundness},${startY}\n            Q ${startX + distanceX / 2},${startY} ${startX + distanceX / 2},${startY + roundness * yMultiplier}\n            L ${startX + distanceX / 2},${stopY - roundness * yMultiplier}\n            Q ${startX + distanceX / 2},${stopY} ${startX + distanceX / 2 + roundness},${stopY}\n            L ${stopX},${stopY}`;\n      }\n      return points;\n    }\n  },\n  computed: {\n    /**\n     * Get tasks which are dependent on other tasks\n     *\n     * @returns {array}\n     */\n    dependencyTasks() {\n      return this.tasks\n        .filter(task => typeof task.dependentOn !== 'undefined')\n        .map(task => {\n          task.dependencyLines = task.dependentOn.map(id => {\n            return { points: this.getPoints(id, task.id) };\n          });\n          return task;\n        })\n        .filter(task => task.dependencyLines.points !== null);\n    }\n  }\n};\n</script>\n"],"sourceRoot":"node_modules/gantt-elastic/src/components/Chart"}]}