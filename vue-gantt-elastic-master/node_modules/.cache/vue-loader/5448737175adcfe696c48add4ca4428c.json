{"remainingRequest":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/gantt-elastic/src/components/Chart/DependencyLines.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/gantt-elastic/src/components/Chart/DependencyLines.vue","mtime":1664650536313},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/cache-loader/dist/cjs.js","mtime":1664650533042},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/babel-loader/lib/index.js","mtime":1664650533420},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/cache-loader/dist/cjs.js","mtime":1664650533042},{"path":"/Users/danieldanio/workspace/daniel-danio-student-code/Capstone/project-schedule-app-final-capstone/vue-gantt-elastic-master/node_modules/vue-loader/lib/index.js","mtime":1664650526464}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nexport default {\n  name: 'DependencyLines',\n  inject: ['root'],\n  props: ['tasks'],\n  data() {\n    return {};\n  },\n  methods: {\n    /**\n     * Get path points\n     *\n     * @param {any} fromTaskId\n     * @param {any} toTaskId\n     * @returns {string}\n     */\n    getPoints(fromTaskId, toTaskId) {\n      const fromTask = this.root.getTask(fromTaskId);\n      const toTask = this.root.getTask(toTaskId);\n      if (\n        fromTask === null ||\n        toTask === null ||\n        !this.root.isTaskVisible(toTask) ||\n        !this.root.isTaskVisible(fromTask)\n      ) {\n        return null;\n      }\n      const startX = fromTask.x + fromTask.width;\n      const startY = fromTask.y + fromTask.height / 2;\n      const stopX = toTask.x;\n      const stopY = toTask.y + toTask.height / 2;\n      const distanceX = stopX - startX;\n      let distanceY;\n      let yMultiplier = 1;\n      if (stopY >= startY) {\n        distanceY = stopY - startY;\n      } else {\n        distanceY = startY - stopY;\n        yMultiplier = -1;\n      }\n      const offset = 10;\n      const roundness = 4;\n      const isBefore = distanceX <= offset + roundness;\n      let points = `M ${startX} ${startY}\n          L ${startX + offset},${startY} `;\n      if (isBefore) {\n        points += `Q ${startX + offset + roundness},${startY} ${startX + offset + roundness},${startY +\n          roundness * yMultiplier}\n            L ${startX + offset + roundness},${startY + (distanceY * yMultiplier) / 2 - roundness * yMultiplier}\n            Q ${startX + offset + roundness},${startY + (distanceY * yMultiplier) / 2} ${startX + offset},${startY +\n          (distanceY * yMultiplier) / 2}\n            L ${startX - offset + distanceX},${startY + (distanceY * yMultiplier) / 2}\n            Q ${startX - offset + distanceX - roundness},${startY + (distanceY * yMultiplier) / 2} ${startX -\n          offset +\n          distanceX -\n          roundness},${startY + (distanceY * yMultiplier) / 2 + roundness * yMultiplier}\n            L ${startX - offset + distanceX - roundness},${stopY - roundness * yMultiplier}\n            Q ${startX - offset + distanceX - roundness},${stopY} ${startX - offset + distanceX},${stopY}\n            L ${stopX},${stopY}`;\n      } else {\n        points += `L ${startX + distanceX / 2 - roundness},${startY}\n            Q ${startX + distanceX / 2},${startY} ${startX + distanceX / 2},${startY + roundness * yMultiplier}\n            L ${startX + distanceX / 2},${stopY - roundness * yMultiplier}\n            Q ${startX + distanceX / 2},${stopY} ${startX + distanceX / 2 + roundness},${stopY}\n            L ${stopX},${stopY}`;\n      }\n      return points;\n    }\n  },\n  computed: {\n    /**\n     * Get tasks which are dependent on other tasks\n     *\n     * @returns {array}\n     */\n    dependencyTasks() {\n      return this.tasks\n        .filter(task => typeof task.dependentOn !== 'undefined')\n        .map(task => {\n          task.dependencyLines = task.dependentOn.map(id => {\n            return { points: this.getPoints(id, task.id) };\n          });\n          return task;\n        })\n        .filter(task => task.dependencyLines.points !== null);\n    }\n  }\n};\n",{"version":3,"sources":["DependencyLines.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"DependencyLines.vue","sourceRoot":"node_modules/gantt-elastic/src/components/Chart","sourcesContent":["<!--\n/**\n * @fileoverview DependencyLines component\n * @license MIT\n * @author Rafal Pospiech <neuronet.io@gmail.com>\n * @package GanttElastic\n */\n-->\n<template>\n  <svg\n    x=\"0\"\n    y=\"0\"\n    width=\"100%\"\n    height=\"100%\"\n    class=\"gantt-elastic__chart-dependency-lines-container\"\n    :style=\"{ ...root.style['chart-dependency-lines-container'] }\"\n  >\n    <g v-for=\"task in dependencyTasks\" :key=\"task.id\" :task=\"task\">\n      <path\n        class=\"gantt-elastic__chart-dependency-lines-path\"\n        :style=\"{ ...root.style['chart-dependency-lines-path'], ...task.style['chart-dependency-lines-path'] }\"\n        v-for=\"dependencyLine in task.dependencyLines\"\n        :key=\"dependencyLine.id\"\n        :task=\"task\"\n        :d=\"dependencyLine.points\"\n      ></path>\n    </g>\n  </svg>\n</template>\n\n<script>\nexport default {\n  name: 'DependencyLines',\n  inject: ['root'],\n  props: ['tasks'],\n  data() {\n    return {};\n  },\n  methods: {\n    /**\n     * Get path points\n     *\n     * @param {any} fromTaskId\n     * @param {any} toTaskId\n     * @returns {string}\n     */\n    getPoints(fromTaskId, toTaskId) {\n      const fromTask = this.root.getTask(fromTaskId);\n      const toTask = this.root.getTask(toTaskId);\n      if (\n        fromTask === null ||\n        toTask === null ||\n        !this.root.isTaskVisible(toTask) ||\n        !this.root.isTaskVisible(fromTask)\n      ) {\n        return null;\n      }\n      const startX = fromTask.x + fromTask.width;\n      const startY = fromTask.y + fromTask.height / 2;\n      const stopX = toTask.x;\n      const stopY = toTask.y + toTask.height / 2;\n      const distanceX = stopX - startX;\n      let distanceY;\n      let yMultiplier = 1;\n      if (stopY >= startY) {\n        distanceY = stopY - startY;\n      } else {\n        distanceY = startY - stopY;\n        yMultiplier = -1;\n      }\n      const offset = 10;\n      const roundness = 4;\n      const isBefore = distanceX <= offset + roundness;\n      let points = `M ${startX} ${startY}\n          L ${startX + offset},${startY} `;\n      if (isBefore) {\n        points += `Q ${startX + offset + roundness},${startY} ${startX + offset + roundness},${startY +\n          roundness * yMultiplier}\n            L ${startX + offset + roundness},${startY + (distanceY * yMultiplier) / 2 - roundness * yMultiplier}\n            Q ${startX + offset + roundness},${startY + (distanceY * yMultiplier) / 2} ${startX + offset},${startY +\n          (distanceY * yMultiplier) / 2}\n            L ${startX - offset + distanceX},${startY + (distanceY * yMultiplier) / 2}\n            Q ${startX - offset + distanceX - roundness},${startY + (distanceY * yMultiplier) / 2} ${startX -\n          offset +\n          distanceX -\n          roundness},${startY + (distanceY * yMultiplier) / 2 + roundness * yMultiplier}\n            L ${startX - offset + distanceX - roundness},${stopY - roundness * yMultiplier}\n            Q ${startX - offset + distanceX - roundness},${stopY} ${startX - offset + distanceX},${stopY}\n            L ${stopX},${stopY}`;\n      } else {\n        points += `L ${startX + distanceX / 2 - roundness},${startY}\n            Q ${startX + distanceX / 2},${startY} ${startX + distanceX / 2},${startY + roundness * yMultiplier}\n            L ${startX + distanceX / 2},${stopY - roundness * yMultiplier}\n            Q ${startX + distanceX / 2},${stopY} ${startX + distanceX / 2 + roundness},${stopY}\n            L ${stopX},${stopY}`;\n      }\n      return points;\n    }\n  },\n  computed: {\n    /**\n     * Get tasks which are dependent on other tasks\n     *\n     * @returns {array}\n     */\n    dependencyTasks() {\n      return this.tasks\n        .filter(task => typeof task.dependentOn !== 'undefined')\n        .map(task => {\n          task.dependencyLines = task.dependentOn.map(id => {\n            return { points: this.getPoints(id, task.id) };\n          });\n          return task;\n        })\n        .filter(task => task.dependencyLines.points !== null);\n    }\n  }\n};\n</script>\n"]}]}